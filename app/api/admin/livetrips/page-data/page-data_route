import { NextResponse } from "next/server";
import { supabaseAdmin } from "@/lib/supabaseAdmin";

export const dynamic = "force-dynamic";
export const revalidate = 0;

function bad(message: string, code: string, status = 400, extra: any = {}) {
  return NextResponse.json(
    { ok: false, code, message, ...extra },
    { status, headers: { "Cache-Control": "no-store" } }
  );
}

function ok(payload: any, status = 200) {
  return NextResponse.json(payload, { status, headers: { "Cache-Control": "no-store" } });
}

function pick(obj: any, keys: string[]) {
  for (const k of keys) {
    if (obj && Object.prototype.hasOwnProperty.call(obj, k)) {
      const v = (obj as any)[k];
      if (v !== null && v !== undefined && String(v).trim() !== "") return v;
    }
  }
  return undefined;
}

/**
 * Accept trips in any shape:
 * - array
 * - { trips: [...] }
 * - { bookings: [...] }
 * - numeric keys: { "0": {...}, "1": {...}, ... }
 */
function extractTripsAnyShape(payload: any): any[] {
  if (!payload) return [];
  if (Array.isArray(payload)) return payload;

  if (typeof payload === "object") {
    const t1 = (payload as any).trips;
    if (Array.isArray(t1)) return t1;

    const t2 = (payload as any).bookings;
    if (Array.isArray(t2)) return t2;

    const t3 = (payload as any).data;
    if (Array.isArray(t3)) return t3;

    // numeric keys
    const keys = Object.keys(payload).filter((k) => /^\d+$/.test(k)).sort((a, b) => Number(a) - Number(b));
    if (keys.length) return keys.map((k) => (payload as any)[k]).filter(Boolean);
  }

  return [];
}

function uniq(arr: string[]) {
  return Array.from(new Set(arr.filter(Boolean)));
}

export async function GET(req: Request) {
  try {
    const supabase = supabaseAdmin();

    // 1) RPC page data
    const { data: rpcData, error: rpcErr } = await supabase.rpc("admin_get_live_trips_page_data");
    if (rpcErr) {
      console.error("LIVETRIPS_RPC_ERROR", rpcErr);
      return bad("LiveTrips RPC failed", "LIVETRIPS_RPC_ERROR", 500, { details: rpcErr.message });
    }

    // 2) Extract trips safely
    const trips = extractTripsAnyShape(rpcData);

    // 3) Gather booking codes + ids from trips
    const bookingCodes = uniq(
      trips
        .map((t: any) => pick(t, ["booking_code", "bookingCode", "code"]))
        .map((v: any) => (v ? String(v) : ""))
    );

    const bookingIds = uniq(
      trips
        .map((t: any) => pick(t, ["id", "uuid", "booking_id", "bookingId"]))
        .map((v: any) => (v ? String(v) : ""))
    );

    // 4) Pull vendor_id / driver_id / trip_type from bookings table to inject into trip objects
    const byCode: Record<string, any> = {};
    const byId: Record<string, any> = {};

    if (bookingCodes.length) {
      const { data: rows, error } = await supabase
        .from("bookings")
        .select("id, booking_code, vendor_id, driver_id, trip_type, town, status")
        .in("booking_code", bookingCodes);

      if (error) {
        console.error("LIVETRIPS_BOOKINGS_BY_CODE_ERROR", error);
        // don't fail the whole endpoint; just continue without enrichment
      } else {
        for (const r of rows ?? []) {
          if (r?.booking_code) byCode[String(r.booking_code)] = r;
          if (r?.id) byId[String(r.id)] = r;
        }
      }
    }

    if (bookingIds.length) {
      const { data: rows, error } = await supabase
        .from("bookings")
        .select("id, booking_code, vendor_id, driver_id, trip_type, town, status")
        .in("id", bookingIds);

      if (error) {
        console.error("LIVETRIPS_BOOKINGS_BY_ID_ERROR", error);
      } else {
        for (const r of rows ?? []) {
          if (r?.id) byId[String(r.id)] = r;
          if (r?.booking_code) byCode[String(r.booking_code)] = r;
        }
      }
    }

    // 5) Inject fields into trips if missing (this fixes the Vendor ledger "No vendor_id" issue)
    for (const t of trips as any[]) {
      const bc = pick(t, ["booking_code", "bookingCode", "code"]);
      const id = pick(t, ["id", "uuid", "booking_id", "bookingId"]);
      const b = (bc && byCode[String(bc)]) || (id && byId[String(id)]) || null;

      if (!b) continue;

      // vendor_id
      const hasVendor = pick(t, ["vendor_id", "vendorId"]);
      if (!hasVendor && b.vendor_id) (t as any).vendor_id = b.vendor_id;

      // driver_id
      const hasDriver = pick(t, ["driver_id", "driverId"]);
      if (!hasDriver && b.driver_id) (t as any).driver_id = b.driver_id;

      // trip_type
      const hasType = pick(t, ["trip_type", "tripType"]);
      if (!hasType && b.trip_type) (t as any).trip_type = b.trip_type;

      // town/zone (optional small assist)
      const hasTown = pick(t, ["town", "zone"]);
      if (!hasTown && b.town) (t as any).zone = b.town;
    }

    // 6) Wallet balances (views you already confirmed exist)
    const driverIds = uniq(
      trips
        .map((t: any) => pick(t, ["driver_id", "driverId"]))
        .map((v: any) => (v ? String(v) : ""))
    );

    const vendorIds = uniq(
      trips
        .map((t: any) => pick(t, ["vendor_id", "vendorId"]))
        .map((v: any) => (v ? String(v) : ""))
    );

    const driverWalletBalances: Record<string, number> = {};
    if (driverIds.length) {
      const { data, error } = await supabase
        .from("driver_wallet_balances_v1")
        .select("driver_id, balance")
        .in("driver_id", driverIds);

      if (error) {
        console.error("DRIVER_WALLET_BALANCES_ERROR", error);
      } else {
        for (const r of data ?? []) {
          if (r?.driver_id != null) driverWalletBalances[String(r.driver_id)] = Number(r.balance ?? 0);
        }
      }
    }

    const vendorWalletBalances: Record<string, number> = {};
    if (vendorIds.length) {
      const { data, error } = await supabase
        .from("vendor_wallet_balances_v1")
        .select("vendor_id, balance")
        .in("vendor_id", vendorIds);

      if (error) {
        console.error("VENDOR_WALLET_BALANCES_ERROR", error);
      } else {
        for (const r of data ?? []) {
          if (r?.vendor_id != null) vendorWalletBalances[String(r.vendor_id)] = Number(r.balance ?? 0);
        }
      }
    }

    // 7) Zones workload (non-fatal if missing)
    let zones: any[] = [];
    try {
      const { data, error } = await supabase.from("zone_capacity_view").select("*");
      if (!error && Array.isArray(data)) zones = data;
    } catch (e) {
      // ignore
    }

    // 8) Response shape: keep numeric keys + trips + balances + zones
    const out: any = {};
    for (let i = 0; i < trips.length; i++) out[String(i)] = trips[i];
    out.trips = trips;
    out.zones = zones;
    out.driverWalletBalances = driverWalletBalances;
    out.vendorWalletBalances = vendorWalletBalances;

    return ok(out);
  } catch (e: any) {
    console.error("LIVETRIPS_PAGE_DATA_UNHANDLED", e);
    return bad("Unhandled error", "UNHANDLED", 500, { details: String(e?.message || e) });
  }
}