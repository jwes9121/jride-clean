import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";

export const dynamic = "force-dynamic";
export const revalidate = 0;

export async function GET() {
  const supabase = createClient();

  // Call the existing RPC for live trips page data
  const [{ data: rpcData, error: rpcError }, { data: zoneData, error: zoneError }] =
    await Promise.all([
      supabase.rpc("admin_get_live_trips_page_data"),
      supabase
        .from("zone_capacity_view")
        .select(
          "zone_id, zone_name, color_hex, capacity_limit, active_drivers, available_slots, status"
        )
        .order("zone_name"),
    ]);

  if (rpcError) {
    console.error("[page-data] live trips RPC error", rpcError);
  // --- WALLET PHASE (SHOW-ALL): enrich trips with wallet balances without touching the DB RPC ---
  function safeArray(v: any) {
    return Array.isArray(v) ? v : [];
  }

  function parseTrips(j: any) {
    if (!j) return [];
    const candidates = [j.trips, j.bookings, j.data, Array.isArray(j) ? j : null];
    for (const c of candidates) {
      const arr = safeArray(c);
      if (arr.length) return arr;
    }
    return [];
  }

  const trips = parseTrips(rpcData);

  // Build driverId + bookingCode lists
  const driverIds = Array.from(
    new Set(
      trips
        .map((t: any) => t?.driver_id ?? t?.driverId ?? null)
        .filter((x: any) => typeof x === "string" && x.length > 0)
    )
  );

  const bookingCodes = Array.from(
    new Set(
      trips
        .map((t: any) => t?.booking_code ?? t?.bookingCode ?? null)
        .filter((x: any) => typeof x === "string" && x.length > 0)
    )
  );

  // Fetch driver balances (view must exist: driver_wallet_balances_v1)
  let driverWalletBalances: Record<string, number> = {};
  if (driverIds.length) {
    const { data: drows, error: derr } = await supabase
      .from("driver_wallet_balances_v1")
      .select("driver_id, balance")
      .in("driver_id", driverIds);

    if (derr) {
      console.error("[wallet] driver balances error", derr);
    } else {
      for (const r of drows ?? []) {
        if (r?.driver_id) driverWalletBalances[String(r.driver_id)] = Number(r.balance ?? 0);
      }
    }
  }

  // Map booking_code -> vendor_id from vendor_wallet_transactions (latest row per booking_code)
  // Then fetch vendor balances from vendor_wallet_balances_v1
  let vendorWalletBalances: Record<string, number> = {};
  let bookingToVendor: Record<string, string> = {};

  if (bookingCodes.length) {
    const { data: vtx, error: vtxErr } = await supabase
      .from("vendor_wallet_transactions")
      .select("booking_code, vendor_id, created_at")
      .in("booking_code", bookingCodes)
      .order("created_at", { ascending: false });

    if (vtxErr) {
      console.error("[wallet] vendor tx lookup error", vtxErr);
    } else {
      for (const row of vtx ?? []) {
        const bc = String(row?.booking_code ?? "");
        const vid = String(row?.vendor_id ?? "");
        if (!bc || !vid) continue;
        // because ordered desc, first occurrence is latest
        if (!bookingToVendor[bc]) bookingToVendor[bc] = vid;
      }

      const vendorIds = Array.from(new Set(Object.values(bookingToVendor)));
      if (vendorIds.length) {
        const { data: vbals, error: vbErr } = await supabase
          .from("vendor_wallet_balances_v1")
          .select("vendor_id, balance")
          .in("vendor_id", vendorIds);

        if (vbErr) {
          console.error("[wallet] vendor balances error", vbErr);
        } else {
          for (const r of vbals ?? []) {
            if (r?.vendor_id) vendorWalletBalances[String(r.vendor_id)] = Number(r.balance ?? 0);
          }
        }
      }
    }
  }

  // Merge balances onto each trip row (TripWalletPanel reads these fields)
  const enrichedTrips = trips.map((t: any) => {
    const driverId = t?.driver_id ?? t?.driverId ?? null;
    const bc = t?.booking_code ?? t?.bookingCode ?? null;

    const driverWallet = driverId ? driverWalletBalances[String(driverId)] : null;

    let vendorWallet: number | null = null;
    if (bc && bookingToVendor[String(bc)]) {
      const vid = bookingToVendor[String(bc)];
      vendorWallet = vendorWalletBalances[vid] ?? null;
    }

    return {
      ...t,
      driver_wallet_balance: driverWallet,
      vendor_wallet_balance: vendorWallet,
    };
  });

  // Preserve original RPC shape, but ensure trips/bookings/data gets enriched if present.
  const mergedRpc =
    rpcData && typeof rpcData === "object" && !Array.isArray(rpcData)
      ? {
          ...(rpcData as any),
          trips: Array.isArray((rpcData as any).trips) ? enrichedTrips : (rpcData as any).trips,
          bookings: Array.isArray((rpcData as any).bookings) ? enrichedTrips : (rpcData as any).bookings,
          data: Array.isArray((rpcData as any).data) ? enrichedTrips : (rpcData as any).data,
        }
      : enrichedTrips;

  return NextResponse.json(
    {
      ...(mergedRpc ?? {}),
      zones: zoneData ?? [],
      // extra debug maps (harmless)
      driverWalletBalances,
      vendorWalletBalances,
    },
    { status: 200 }
  );