import { NextResponse } from "next/server";
import { createClient as createSbClient } from "@supabase/supabase-js";
export const dynamic = "force-dynamic";
export const revalidate = 0;

function safeArray(v: any): any[] {
  return Array.isArray(v) ? v : [];
}

function extractTrips(rpcData: any): any[] {
  if (!rpcData) return [];
  if (Array.isArray(rpcData)) return rpcData;

  // common shapes from RPCs
  const cands = [rpcData.trips, rpcData.bookings, rpcData.data];
  for (const c of cands) {
    const arr = safeArray(c);
    if (arr.length) return arr;
  }
  return [];
}

export async function GET() {
  // Admin API must not depend on browser session cookies (RLS-safe).
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceKey =
    process.env.SUPABASE_SERVICE_ROLE_KEY ||
    process.env.SUPABASE_SERVICE_KEY ||
    "";

  if (!supabaseUrl) {
    return NextResponse.json({ error: "Missing NEXT_PUBLIC_SUPABASE_URL" }, { status: 500 });
  }
  if (!serviceKey) {
    return NextResponse.json({ error: "Missing SUPABASE_SERVICE_ROLE_KEY" }, { status: 500 });
  }

  const supabase = createSbClient(supabaseUrl, serviceKey);
  // Call existing RPC + zones in parallel
  const [{ data: rpcData, error: rpcError }, { data: zoneData, error: zoneError }] =
    await Promise.all([
      supabase.rpc("admin_get_live_trips_page_data"),
      supabase
        .from("zone_capacity_view")
        .select(
          "zone_id, zone_name, color_hex, capacity_limit, active_drivers, available_slots, status"
        )
        .order("zone_name"),
    ]);

  if (rpcError) {
    console.error("[page-data] live trips RPC error", rpcError);
    return NextResponse.json({ error: rpcError.message }, { status: 500 });
  }

  if (zoneError) {
    console.error("[zone-capacity] error", zoneError);
    return NextResponse.json({ error: zoneError.message }, { status: 500 });
  }

  // --- WALLET PHASE STEP 2 (SHOW-ALL) ---
  // Best-effort enrichment; never breaks response if wallet queries fail.
  let driverWalletBalances: Record<string, number> = {};
  let vendorWalletBalances: Record<string, number> = {};
  let bookingToVendor: Record<string, string> = {};

  try {
    const trips = extractTrips(rpcData);

    const driverIds = Array.from(
      new Set(
        trips
          .map((t: any) => t?.driver_id ?? t?.driverId ?? null)
          .filter((x: any) => typeof x === "string" && x.length > 0)
      )
    );

    const bookingCodes = Array.from(
      new Set(
        trips
          .map((t: any) => t?.booking_code ?? t?.bookingCode ?? null)
          .filter((x: any) => typeof x === "string" && x.length > 0)
      )
    );

    // Driver balances
    if (driverIds.length) {
      const { data: drows, error: derr } = await supabase
        .from("driver_wallet_balances_v1")
        .select("driver_id, balance")
        .in("driver_id", driverIds);

      if (derr) {
        console.error("[wallet] driver_wallet_balances_v1 error", derr);
      } else {
        for (const r of drows ?? []) {
          if (r?.driver_id) driverWalletBalances[String(r.driver_id)] = Number(r.balance ?? 0);
        }
      }
    }

    // booking_code -> vendor_id mapping (latest tx per booking_code)
    if (bookingCodes.length) {
      const { data: vtx, error: vtxErr } = await supabase
        .from("vendor_wallet_transactions")
        .select("booking_code, vendor_id, created_at")
        .in("booking_code", bookingCodes)
        .order("created_at", { ascending: false });

      if (vtxErr) {
        console.error("[wallet] vendor_wallet_transactions lookup error", vtxErr);
      } else {
        for (const row of vtx ?? []) {
          const bc = String(row?.booking_code ?? "");
          const vid = String(row?.vendor_id ?? "");
          if (!bc || !vid) continue;
          if (!bookingToVendor[bc]) bookingToVendor[bc] = vid; // first is latest (ordered desc)
        }

        const vendorIds = Array.from(new Set(Object.values(bookingToVendor)));
        if (vendorIds.length) {
          const { data: vbals, error: vbErr } = await supabase
            .from("vendor_wallet_balances_v1")
            .select("vendor_id, balance")
            .in("vendor_id", vendorIds);

          if (vbErr) {
            console.error("[wallet] vendor_wallet_balances_v1 error", vbErr);
          } else {
            for (const r of vbals ?? []) {
              if (r?.vendor_id) vendorWalletBalances[String(r.vendor_id)] = Number(r.balance ?? 0);
            }
          }
        }
      }
    }

    // merge onto trips
    if (trips.length) {
      const enrichedTrips = trips.map((t: any) => {
        const driverId = t?.driver_id ?? t?.driverId ?? null;
        const bc = t?.booking_code ?? t?.bookingCode ?? null;

        const driverWallet = driverId ? driverWalletBalances[String(driverId)] : null;

        let vendorWallet: number | null = null;
        if (bc && bookingToVendor[String(bc)]) {
          const vid = bookingToVendor[String(bc)];
          vendorWallet = vendorWalletBalances[vid] ?? null;
        }

        return {
          ...t,
          driver_wallet_balance: driverWallet,
          vendor_wallet_balance: vendorWallet,
        };
      });

      // preserve rpcData container shape if object; else return array
      if (rpcData && typeof rpcData === "object" && !Array.isArray(rpcData)) {
        if (Array.isArray((rpcData as any).trips)) (rpcData as any).trips = enrichedTrips;
        if (Array.isArray((rpcData as any).bookings)) (rpcData as any).bookings = enrichedTrips;
        if (Array.isArray((rpcData as any).data)) (rpcData as any).data = enrichedTrips;
      } else {
        // rpcData was an array
      }
    }
  } catch (e: any) {
    console.error("[wallet] enrichment failed (non-blocking)", e?.message || e);
  }

  return NextResponse.json(
    {
      ...(rpcData ?? {}),
      zones: zoneData ?? [],
      // debug maps (harmless; can be removed later)
      driverWalletBalances,
      vendorWalletBalances,
    },
    { status: 200 }
  );
}