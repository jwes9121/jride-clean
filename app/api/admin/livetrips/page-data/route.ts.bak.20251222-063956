import { NextResponse } from "next/server";
import { createClient as createSbClient } from "@supabase/supabase-js";
export const dynamic = "force-dynamic";
export const revalidate = 0;

function safeArray(v: any): any[] {
  return Array.isArray(v) ? v : [];
}

function extractTrips(rpcData: any): any[] {
  if (!rpcData) return [];
  if (Array.isArray(rpcData)) return rpcData;

  // common shapes from RPCs
  const cands = [rpcData.trips, rpcData.bookings, rpcData.data];
  for (const c of cands) {
    const arr = safeArray(c);
    if (arr.length) return arr;
  }
  return [];
}

export async function GET() {
  // Admin API must not depend on browser session cookies (RLS-safe).
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceKey =
    process.env.SUPABASE_SERVICE_ROLE_KEY ||
    process.env.SUPABASE_SERVICE_KEY ||
    "";

  if (!supabaseUrl) {
  // ===== NUMERIC_KEY_TRIPS_FIX (wallet merge safe) =====

  function extractTripsAnyShape(src: any): any[] {
    if (!src) return [];
    if (Array.isArray(src)) return src;

    if (typeof src === "object") {
      // numeric-key object: { "0": {...}, "1": {...} }
      const numericKeys = Object.keys(src).filter(k => /^\d+$/.test(k));
      if (numericKeys.length) {
        return numericKeys
          .sort((a,b)=>Number(a)-Number(b))
          .map(k => src[k]);
      }
    }
    return [];
  }

  const baseTrips = extractTripsAnyShape(rpcData);

  const enrichedTrips = baseTrips.map((t: any) => {
    const driverId = t.driver_id ?? t.driverId ?? null;
    const bookingCode = t.booking_code ?? t.bookingCode ?? null;

    const driverWallet =
      driverId && driverWalletBalances[String(driverId)] !== undefined
        ? driverWalletBalances[String(driverId)]
        : null;

    let vendorWallet = null;
    if (bookingCode && bookingToVendor[String(bookingCode)]) {
      const vid = bookingToVendor[String(bookingCode)];
      if (vendorWalletBalances[vid] !== undefined) {
        vendorWallet = vendorWalletBalances[vid];
      }
    }

    return {
      ...t,
      driver_wallet_balance: driverWallet,
      vendor_wallet_balance: vendorWallet,
    };
  });

  // Rebuild numeric-key object for backward compatibility
  const numericPayload: any = {};
  enrichedTrips.forEach((t, i) => { numericPayload[String(i)] = t; });

  return NextResponse.json(
    {
      ...numericPayload,
      trips: enrichedTrips,
      zones: zoneData ?? [],
      driverWalletBalances,
      vendorWalletBalances,
    },
    { status: 200 }
  );

  // ===== END NUMERIC_KEY_TRIPS_FIX =====
}