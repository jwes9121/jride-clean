import { NextRequest, NextResponse } from "next/server";
import { auth } from "../../../../auth";
import { supabaseAdmin } from "@/lib/supabaseAdmin";

/* JRIDE_DEV_BYPASS_DISPATCH_BOOKINGS */
function jrideDevBypass(req: any): boolean {
  try {
    // Only allow bypass in non-production AND only for localhost requests
    if (process.env.NODE_ENV === "production") return false;
    const host = String(req?.headers?.get?.("host") || "");
    if (!host.includes("localhost") && !host.includes("127.0.0.1")) return false;

    // Optional header toggle (not required)
    const h = String(req?.headers?.get?.("x-jride-dev-bypass") || "");
    if (h === "1") return true;

    // Default: localhost in dev = bypass enabled
    return true;
  } catch {
    return false;
  }
}

function jsonError(msg: string, code = 400) {
  return NextResponse.json({ error: msg }, { status: code });
}
function isAllowed(role?: string) {
  return role === "admin" || role === "dispatcher";
}

export async function GET(req: NextRequest) {
  const __JRIDE_DEV_BYPASS__ = jrideDevBypass(req);
  const session = await auth();
  const role = (session?.user as any)?.role;
  if (!__JRIDE_DEV_BYPASS__ && !isAllowed(role)) return jsonError("Forbidden", 403);

  const sb = supabaseAdmin();
  const { searchParams } = new URL(req.url);
  const since = searchParams.get("since"); // optional ISO string

  let query = sb.from("bookings").select("*").order("created_at", { ascending: false }).limit(200);
  if (since) query = query.gte("created_at", since);

  const { data, error } = await query;
  if (error) return jsonError(error.message, 500);
  return NextResponse.json({ rows: data || [] });
}

export async function POST(req: NextRequest) {

  const __JRIDE_DEV_BYPASS__ = jrideDevBypass(req);
  // JRIDE_DEV_BYPASS_NOTE: localhost dev bypass enabled; auth-gate should not block create in dev.

  const session = await auth();
  const role = (session?.user as any)?.role;
  const email = session?.user?.email || "";

  // If NOT allowed and NOT dev-bypass, forbid.
  if (!isAllowed(role) && !__JRIDE_DEV_BYPASS__) return jsonError("Forbidden", 403);

  let body: any = null;
  try { body = await req.json(); } catch { return jsonError("Invalid JSON"); }

  const sb = supabaseAdmin();

  // --------- Schema-safe insert (DO NOT assume columns exist) ----------
  // Pull one row to learn available columns (schema cache safe)
  const probe = await sb.from("bookings").select("*").limit(1);
  const sample = (probe.data && probe.data[0]) ? probe.data[0] : {};
  const allowed = new Set(Object.keys(sample || {}));

  // Candidates (we filter to allowed keys below)
  const town = String(body.town || "").trim() || null;

  const candidate: any = {
    trip_type: "takeout",
    town: town,
    status: "new",

    // Optional takeout support
    takeout_service_level: (body as any)?.takeout_service_level ?? "regular",
    vendor_id: (body as any)?.vendor_id ?? null,

    // Optional labels/coords/notes/etc (will be dropped if columns don't exist)
    pickup_label: body.pickup_label ?? null,
    dropoff_label: body.dropoff_label ?? null,
    pickup_lat: body.pickup_lat ?? null,
    pickup_lng: body.pickup_lng ?? null,
    dropoff_lat: body.dropoff_lat ?? null,
    dropoff_lng: body.dropoff_lng ?? null,
    distance_km: body.distance_km ?? null,
    fare: body.fare ?? null,
    notes: body.notes ?? null,
    rider_name: body.rider_name ?? null,
    rider_phone: body.rider_phone ?? null,
    dispatcher_email: email || null,
  };

  // Filter to allowed columns ONLY
  const insert: any = {};
  for (const k of Object.keys(candidate)) {
    if (allowed.has(k)) insert[k] = candidate[k];
  }

  // Minimal requirement: we need at least trip_type/status
  if (!Object.keys(insert).length) return jsonError("No compatible columns found for insert()", 500);

  const { data, error } = await sb.from("bookings").insert(insert).select("*").single();
  if (error) return jsonError(error.message, 500);

  return NextResponse.json({ row: data });
}
  if (error) return jsonError(error.message, 500);

  await sb.from("dispatcher_action_logs").insert({
    booking_id: data.id,
    action: "created",
    actor_email: email,
    details: insert as any,
  });

  return NextResponse.json({ row: data });
}












