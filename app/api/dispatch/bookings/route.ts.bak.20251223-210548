import { NextRequest, NextResponse } from "next/server";
import { auth } from "../../../../auth";
import { supabaseAdmin } from "@/lib/supabaseAdmin";

/* JRIDE_DEV_BYPASS_DISPATCH_BOOKINGS */
function jrideDevBypass(req: any): boolean {
  try {
    // Only allow bypass in non-production AND only for localhost requests
    if (process.env.NODE_ENV === "production") return false;
    const host = String(req?.headers?.get?.("host") || "");
    if (!host.includes("localhost") && !host.includes("127.0.0.1")) return false;

    // Optional header toggle (not required)
    const h = String(req?.headers?.get?.("x-jride-dev-bypass") || "");
    if (h === "1") return true;

    // Default: localhost in dev = bypass enabled
    return true;
  } catch {
    return false;
  }
}

function jsonError(msg: string, code = 400) {
  return NextResponse.json({ error: msg }, { status: code });
}
function isAllowed(role?: string) {
  return role === "admin" || role === "dispatcher";
}

export async function GET(req: NextRequest) {
  const __JRIDE_DEV_BYPASS__ = jrideDevBypass(req);
  const session = await auth();
  const role = (session?.user as any)?.role;
  if (!__JRIDE_DEV_BYPASS__ && !isAllowed(role)) return jsonError("Forbidden", 403);

  const sb = supabaseAdmin();
  const { searchParams } = new URL(req.url);
  const since = searchParams.get("since"); // optional ISO string

  let query = sb.from("bookings").select("*").order("created_at", { ascending: false }).limit(200);
  if (since) query = query.gte("created_at", since);

  const { data, error } = await query;
  if (error) return jsonError(error.message, 500);
  return NextResponse.json({ rows: data || [] });
}

export async function POST(req: NextRequest) {
  
  const __JRIDE_DEV_BYPASS__ = jrideDevBypass(req);
  // JRIDE_DEV_BYPASS_NOTE: localhost dev bypass enabled; auth-gate should not block create in dev.

const session = await auth();
  const role = (session?.user as any)?.role;
  const email = session?.user?.email || "";
  if (!__JRIDE_DEV_BYPASS__ && !isAllowed(role)) return jsonError("Forbidden", 403);

  let body: any = null;
  try { body = await req.json(); } catch { return jsonError("Invalid JSON"); }

  
  const serviceType = String((body as any)?.service_type || "").trim().toLowerCase();
  const pickup_label = String((body as any)?.pickup_label || (body as any)?.from_label || "").trim();
  const dropoff_label = String((body as any)?.dropoff_label || (body as any)?.to_label || "").trim();
  const vendor_id = String((body as any)?.vendor_id || "").trim();
const pickup_lat = Number(body.pickup_lat);
  const pickup_lng = Number(body.pickup_lng);
  const town = String(body.town || "").trim();
  if (serviceType !== "takeout" && (!pickup_lat || !pickup_lng || !town)) return jsonError("pickup_lat, pickup_lng, town required");

  const sb = supabaseAdmin();
  const insert = {
    takeout_service_level: (body as any)?.takeout_service_level ?? "regular",
    
    vendor_id: vendor_id || null,
rider_name: String(body.rider_name || ""),
    rider_phone: String(body.rider_phone || ""),
    pickup_lat, pickup_lng,
    dropoff_lat: body.dropoff_lat ? Number(body.dropoff_lat) : null,
    dropoff_lng: body.dropoff_lng ? Number(body.dropoff_lng) : null,
    town,
};

  const { data, error } = await sb.from("bookings").insert(insert).select("*").single();
  if (error) return jsonError(error.message, 500);

  await sb.from("dispatcher_action_logs").insert({
    booking_id: data.id,
    action: "created",
    actor_email: email,
    details: insert as any,
  });

  return NextResponse.json({ row: data });
}









