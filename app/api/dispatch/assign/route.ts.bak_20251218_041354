import { NextResponse } from "next/server";
import { supabaseAdmin } from "@/lib/supabaseAdmin";

export const dynamic = "force-dynamic";

type Body = {
  bookingId?: string | null;
  bookingCode?: string | null;
  driverId?: string | null;
  override?: boolean | null;
  source?: string | null;
};

function isLockedStatus(s: string) {
  const x = (s || "").toLowerCase().trim();
  return x === "on_trip" || x === "completed" || x === "cancelled";
}

export async function POST(req: Request) {
  try {
    const supabase = supabaseAdmin();
    const body = (await req.json().catch(() => ({}))) as Body;

    const bookingId = String(body.bookingId ?? "").trim();
    const bookingCode = String(body.bookingCode ?? "").trim();
    const driverId = String(body.driverId ?? "").trim();
    const source = String(body.source ?? "unknown").trim();

    if (!driverId) return NextResponse.json({ error: "MISSING_DRIVER_ID" }, { status: 400 });
    if (!bookingId && !bookingCode) {
      return NextResponse.json({ error: "MISSING_BOOKING_IDENTIFIER" }, { status: 400 });
    }

    // Resolve booking + current state
    let readQ = supabase.from("bookings").select("id, booking_code, status, driver_id").limit(1);
    if (bookingId) readQ = readQ.eq("id", bookingId);
    else readQ = readQ.eq("booking_code", bookingCode);

    const { data: curRows, error: curErr } = await readQ;
    if (curErr) {
      console.error("DISPATCH_ASSIGN_READ_ERROR", curErr);
      return NextResponse.json({ error: "DISPATCH_ASSIGN_READ_ERROR", message: curErr.message }, { status: 500 });
    }

    const cur = (curRows ?? [])[0] as any;
    const currentStatus = String(cur?.status ?? "").trim();
    const fromDriverId = String(cur?.driver_id ?? "").trim();
    const resolvedBookingId = String(cur?.id ?? "").trim();
    const resolvedBookingCode = String(cur?.booking_code ?? bookingCode ?? "").trim();

    if (!resolvedBookingId) {
      return NextResponse.json({ error: "BOOKING_NOT_FOUND" }, { status: 404 });
    }

    if (isLockedStatus(currentStatus)) {
      return NextResponse.json(
        { error: "ASSIGN_LOCKED", message: `Assignment locked when status='${currentStatus}'.` },
        { status: 409 }
      );
    }

    const nowIso = new Date().toISOString();

    // Update by resolved id; verify 1 row updated
    const { data: updRows, error: updErr } = await supabase
      .from("bookings")
      .update({
        driver_id: driverId,
        assigned_driver_id: driverId,
        assigned_at: nowIso,
        status: "assigned",
        updated_at: nowIso,
      })
      .eq("id", resolvedBookingId)
      .select("id, booking_code, status, driver_id")
      .limit(1);

    if (updErr) {
      console.error("DISPATCH_ASSIGN_DB_ERROR", updErr);
      return NextResponse.json({ error: "DISPATCH_ASSIGN_DB_ERROR", message: updErr.message }, { status: 500 });
    }

    const upd = (updRows ?? [])[0] as any;
    if (!upd?.id) {
      return NextResponse.json({ error: "ASSIGN_NO_ROWS", message: "No rows updated (identifier mismatch)." }, { status: 409 });
    }

    // Best-effort audit log (won't break assignment)
    try {
      await supabase.from("booking_assignment_log").insert({
        booking_id: resolvedBookingId || null,
        booking_code: resolvedBookingCode || null,
        from_driver_id: fromDriverId || null,
        to_driver_id: driverId,
        source,
        actor: "admin",
        note: source === "override" ? "Emergency override used" : null,
      });
    } catch (e) {
      console.warn("ASSIGN_LOG_INSERT_FAILED", e);
    }

    return NextResponse.json(
      {
        ok: true,
        bookingId: resolvedBookingId,
        bookingCode: resolvedBookingCode,
        fromDriverId: fromDriverId || null,
        toDriverId: driverId,
        status: String(upd.status ?? "assigned"),
        assignedAt: nowIso,
      },
      { status: 200 }
    );
  } catch (err: any) {
    console.error("DISPATCH_ASSIGN_UNEXPECTED", err);
    return NextResponse.json(
      { error: "DISPATCH_ASSIGN_UNEXPECTED", message: err?.message ?? "Unexpected error" },
      { status: 500 }
    );
  }
}
