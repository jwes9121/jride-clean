import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic";
export const revalidate = 0;

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

function bad(message: string, code: string, status = 400, extra: any = {}) {
  return NextResponse.json(
    { ok: false, code, message, ...extra },
    { status, headers: { "Cache-Control": "no-store" } }
  );
}

function ok(data: any = {}) {
  return NextResponse.json(
    { ok: true, ...data },
    { headers: { "Cache-Control": "no-store" } }
  );
}

async function auditAssign(params: {
  bookingCode?: string;
  driverId?: string;
  actor?: string;
  ok: boolean;
  code?: string;
  message?: string;
  meta?: any;
}) {
  try {
    await supabase.from("dispatch_assign_audit").insert({
      booking_code: params.bookingCode ?? null,
      driver_id: params.driverId ?? null,
      actor: params.actor ?? "unknown",
      ok: !!params.ok,
      code: params.code ?? null,
      message: params.message ?? null,
      meta: params.meta ?? {},
    });
  } catch {
    // never block dispatch on audit failures
  }
}

export async function POST(req: Request) {
  let bookingCode = "";
  let driverId = "";
  let actor = "unknown";
  let meta: any = {};

  try {
    const body = await req.json().catch(() => ({} as any));

    // IMPORTANT: Trim inputs (fixes BOOKING_NOT_FOUND when pasted with newline/space)
    bookingCode = String(body?.bookingCode ?? "").trim();
    driverId = String(body?.driverId ?? "").trim();

    actor =
      (req.headers.get("x-user-email") ||
        req.headers.get("x-forwarded-email") ||
        req.headers.get("x-vercel-user-email") ||
        "unknown") as string;

    meta = {
      ip: req.headers.get("x-forwarded-for") || req.headers.get("x-real-ip") || null,
      userAgent: req.headers.get("user-agent") || null,
      host: req.headers.get("host") || null,
    };

    if (!bookingCode) {
      await auditAssign({ bookingCode, driverId, actor, ok: false, code: "MISSING_BOOKING", message: "Missing bookingCode", meta });
      return bad("Missing bookingCode", "MISSING_BOOKING", 400);
    }

    if (!driverId) {
      await auditAssign({ bookingCode, driverId, actor, ok: false, code: "MISSING_DRIVER", message: "Missing driverId", meta });
      return bad("Missing driverId", "MISSING_DRIVER", 400);
    }

    // 1) Fetch booking
    const { data: booking, error: bookingErr } = await supabase
      .from("bookings")
      .select("id,status,driver_id")
      .eq("booking_code", bookingCode)
      .maybeSingle();

    if (bookingErr || !booking) {
      await auditAssign({
        bookingCode,
        driverId,
        actor,
        ok: false,
        code: "BOOKING_NOT_FOUND",
        message: "Booking not found",
        meta: { ...meta, bookingErr: bookingErr?.message ?? null },
      });
      return bad("Booking not found", "BOOKING_NOT_FOUND", 404, { bookingCode });
    }

    if (booking.driver_id) {
      await auditAssign({ bookingCode, driverId, actor, ok: false, code: "ALREADY_ASSIGNED", message: "Booking already assigned", meta });
      return bad("Booking already assigned", "ALREADY_ASSIGNED", 409);
    }

    if (["on_trip", "completed", "cancelled"].includes(String(booking.status))) {
      await auditAssign({ bookingCode, driverId, actor, ok: false, code: "NOT_ASSIGNABLE", message: "Booking not assignable", meta });
      return bad("Booking not assignable", "NOT_ASSIGNABLE", 409, { status: booking.status });
    }

    // 2) Ensure driver is not busy
    const { count: activeCount, error: busyErr } = await supabase
      .from("bookings")
      .select("id", { count: "exact", head: true })
      .eq("driver_id", driverId)
      .in("status", ["assigned", "on_the_way", "on_trip"]);

    if (busyErr) {
      await auditAssign({
        bookingCode,
        driverId,
        actor,
        ok: false,
        code: "BUSY_CHECK_FAILED",
        message: "Driver busy check failed",
        meta: { ...meta, busyErr: busyErr.message },
      });
      return bad("Driver busy check failed", "BUSY_CHECK_FAILED", 500);
    }

    if ((activeCount ?? 0) > 0) {
      await auditAssign({ bookingCode, driverId, actor, ok: false, code: "DRIVER_BUSY", message: "Driver already on active trip", meta });
      return bad("Driver already on active trip", "DRIVER_BUSY", 409);
    }

    // 2.5) Wallet minimum balance precheck (NEXT_WALLETS_PHASE)
    const minRequired = Number(process.env.MIN_DRIVER_WALLET_REQUIRED || "0");
    if (Number.isFinite(minRequired) && minRequired > 0) {
      const { data: balRow, error: balErr } = await supabase
        .from("driver_wallet_balances_v1")
        .select("balance")
        .eq("driver_id", driverId)
        .maybeSingle();

      if (balErr) {
        await auditAssign({
          bookingCode,
          driverId,
          actor,
          ok: false,
          code: "WALLET_CHECK_FAILED",
          message: "Wallet balance check failed",
          meta: { ...meta, walletError: balErr.message },
        });
        return bad("Wallet balance check failed", "WALLET_CHECK_FAILED", 500);
      }

      const balance = Number(balRow?.balance ?? 0);
      if (!Number.isFinite(balance)) {
        await auditAssign({
          bookingCode,
          driverId,
          actor,
          ok: false,
          code: "WALLET_BALANCE_INVALID",
          message: "Wallet balance invalid",
          meta: { ...meta, balance: balRow?.balance },
        });
        return bad("Wallet balance invalid", "WALLET_BALANCE_INVALID", 409);
      }

      if (balance < minRequired) {
        await auditAssign({
          bookingCode,
          driverId,
          actor,
          ok: false,
          code: "INSUFFICIENT_BALANCE",
          message: "Driver wallet below minimum",
          meta: { ...meta, balance, minRequired },
        });
        return bad("Driver wallet below minimum", "INSUFFICIENT_BALANCE", 409, { balance, minRequired });
      }
    }

    // 3) Assign with optimistic lock
    const { data: updated, error: updateErr } = await supabase
      .from("bookings")
      .update({
        driver_id: driverId,
        assigned_driver_id: driverId,
        assigned_at: new Date().toISOString(),
        status: "assigned",
      })
      .eq("booking_code", bookingCode)
      .is("driver_id", null)
      .select("id");

    if (updateErr || !updated || updated.length === 0) {
      await auditAssign({
        bookingCode,
        driverId,
        actor,
        ok: false,
        code: "NO_ROWS_UPDATED",
        message: "Assignment failed (no rows updated)",
        meta: { ...meta, updateErr: updateErr?.message ?? null },
      });
      return bad("Assignment failed (no rows updated)", "NO_ROWS_UPDATED", 409, { bookingCode, driverId });
    }

    await auditAssign({ bookingCode, driverId, actor, ok: true, code: "OK", message: "assigned", meta });
    return ok({ bookingCode, driverId });
  } catch (e: any) {
    await auditAssign({
      bookingCode,
      driverId,
      actor,
      ok: false,
      code: "INTERNAL_ERROR",
      message: "Internal server error",
      meta: { ...meta, error: String(e?.message || e) },
    });
    return bad("Internal server error", "INTERNAL_ERROR", 500, { error: String(e?.message || e) });
  }
}