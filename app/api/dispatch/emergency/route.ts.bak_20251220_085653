import { NextResponse } from "next/server";

type Body = {
  bookingId?: string;
  bookingCode?: string;
  isEmergency?: boolean; // if omitted, we toggle
  dispatcherName?: string | null;
};

function bad(message: string, status = 400) {
  return NextResponse.json({ ok: false, message }, { status });
}

export async function POST(req: Request) {
  const supabaseUrl = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_SERVICE_KEY;

  if (!supabaseUrl) return bad("Missing SUPABASE_URL / NEXT_PUBLIC_SUPABASE_URL", 500);
  if (!supabaseServiceKey) return bad("Missing SUPABASE_SERVICE_ROLE_KEY (recommended) / SUPABASE_SERVICE_KEY", 500);

  let body: Body;
  try {
    body = (await req.json()) as Body;
  } catch {
    return bad("Invalid JSON body");
  }

  const bookingId = body.bookingId || body.bookingCode;
  const bookingCode = body.bookingCode;
  if (!bookingId && !bookingCode) return bad("Missing bookingId/bookingCode");

  const base = `${supabaseUrl}/rest/v1/bookings`;
  const where = bookingCode
    ? `booking_code=eq.${encodeURIComponent(bookingCode)}`
    : `id=eq.${encodeURIComponent(String(bookingId))}`;

  // 1) Read current is_emergency (so we can toggle if not provided)
  const getUrl = `${base}?${where}&select=id,is_emergency`;
  try {
    const getRes = await fetch(getUrl, {
      method: "GET",
      headers: { apikey: supabaseServiceKey, Authorization: `Bearer ${supabaseServiceKey}` },
    });
    const getText = await getRes.text();
    if (!getRes.ok) {
      return NextResponse.json(
        { ok: false, message: "READ_FAILED", status: getRes.status, detail: getText },
        { status: getRes.status }
      );
    }

    let rows: any[] = [];
    try { rows = JSON.parse(getText); } catch { rows = []; }

    const current = rows?.[0];
    if (!current) return bad("Booking not found", 404);

    const nextVal =
      typeof body.isEmergency === "boolean"
        ? body.isEmergency
        : !Boolean(current.is_emergency);

    const patchUrl = `${base}?${where}`;
    const patchRes = await fetch(patchUrl, {
      method: "PATCH",
      headers: {
        apikey: supabaseServiceKey,
        Authorization: `Bearer ${supabaseServiceKey}`,
        "Content-Type": "application/json",
        Prefer: "return=representation",
      },
      body: JSON.stringify({ is_emergency: nextVal }),
    });

    const patchText = await patchRes.text();
    if (!patchRes.ok) {
      return NextResponse.json(
        { ok: false, message: "PATCH_FAILED", status: patchRes.status, detail: patchText },
        { status: patchRes.status }
      );
    }

    return NextResponse.json({ ok: true, is_emergency: nextVal, result: patchText }, { status: 200 });
  } catch (err: any) {
    console.error("dispatch/emergency error:", err);
    return NextResponse.json(
      { ok: false, message: "EMERGENCY_ROUTE_ERROR", detail: String(err?.message || err) },
      { status: 500 }
    );
  }
}