"use client";

import * as React from "react";

type Booking = {
  id: string;

  rider_name?: string | null;
  rider_phone?: string | null;

  pickup_label?: string | null;
  dropoff_label?: string | null;

  pickup_lat?: number | null;
  pickup_lng?: number | null;
  dropoff_lat?: number | null;
  dropoff_lng?: number | null;

  town?: string | null;
  distance_km?: number | null;
  fare?: number | null;

  status?: string | null;
  driver_id?: string | null;

  created_at?: string | null;
  updated_at?: string | null;

  service_type?: string | null;
  trip_type?: string | null;
  vendor_id?: string | null;
  takeout_service_level?: "regular" | "express" | null;

  booking_code?: string | null;
};

type DriverRow = {
  id: string;
  town?: string | null;
  status?: string | null; // "online" | "busy" | etc
  lat?: number | null;
  lng?: number | null;
  last_seen?: string | null;
};

function normTown(v: any) {
  return String(v ?? "").trim().toLowerCase();
}

function isShortId(v: any) {
  const s = String(v ?? "");
  return s.length > 0 && s.length < 20;
}

function isOnlineLike(status: any) {
  const s = String(status ?? "").trim().toLowerCase();
  return s === "online" || s === "available" || s === "idle";
}

function haversineMeters(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371000;
  const toRad = (d: number) => (d * Math.PI) / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function pickNearestEligibleDriverId(b: Booking, drivers: DriverRow[], forceAssign: boolean): string {
  const townKey = normTown(b.town);

  const sameTown = drivers.filter((d) => normTown(d.town) === townKey);
  const pool = sameTown.length ? sameTown : drivers;

  const online = pool.filter((d) => isOnlineLike(d.status));
  const eligible = forceAssign ? pool : online;
  if (!eligible.length) return "";

  const plat = typeof b.pickup_lat === "number" ? b.pickup_lat : null;
  const plng = typeof b.pickup_lng === "number" ? b.pickup_lng : null;

  // If pickup coords missing -> safe fallback (first eligible)
  if (plat === null || plng === null) return eligible[0].id;

  // Only consider drivers with coords for distance sort; if none -> fallback first eligible
  const withCoords = eligible.filter((d) => typeof d.lat === "number" && typeof d.lng === "number");
  if (!withCoords.length) return eligible[0].id;

  let bestId = withCoords[0].id;
  let bestDist = haversineMeters(plat, plng, withCoords[0].lat as number, withCoords[0].lng as number);

  for (let i = 1; i < withCoords.length; i++) {
    const d = withCoords[i];
    const dist = haversineMeters(plat, plng, d.lat as number, d.lng as number);
    if (dist < bestDist) {
      bestDist = dist;
      bestId = d.id;
    }
  }
  return bestId;
}

export default function DispatchPage(): JSX.Element {
  const [rows, setRows] = React.useState<Booking[]>([]);
  const [loading, setLoading] = React.useState<boolean>(true);
  const [error, setError] = React.useState<string | null>(null);

  // create form
  const [serviceType, setServiceType] = React.useState<"dispatch" | "takeout">("dispatch");

  // dispatch/local fields
  const [riderName, setRiderName] = React.useState<string>("");
  const [riderPhone, setRiderPhone] = React.useState<string>("");
  const [town, setTown] = React.useState<string>("");
  const [pickupLat, setPickupLat] = React.useState<string>("");
  const [pickupLng, setPickupLng] = React.useState<string>("");

  // takeout fields
  const [vendorId, setVendorId] = React.useState<string>("");
  const [takeoutLevel, setTakeoutLevel] = React.useState<"regular" | "express">("regular");
  const [pickupLabel, setPickupLabel] = React.useState<string>("");
  const [dropoffLabel, setDropoffLabel] = React.useState<string>("");

  // drivers + per-row selection
  const [drivers, setDrivers] = React.useState<DriverRow[]>([]);
  const [driversError, setDriversError] = React.useState<string | null>(null);
  const [selectedDriverByBookingId, setSelectedDriverByBookingId] = React.useState<Record<string, string>>({});
  const [forceAssign, setForceAssign] = React.useState<boolean>(false);

  // auto-assign when creating a booking
  const [autoAssignOnCreate, setAutoAssignOnCreate] = React.useState<boolean>(true);

  // per-row pending flags
  const [pendingByBookingId, setPendingByBookingId] = React.useState<Record<string, boolean>>({});

  function setPending(bookingId: string, v: boolean) {
    setPendingByBookingId((prev) => ({ ...prev, [bookingId]: v }));
  }

  async function load() {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/dispatch/bookings", { cache: "no-store" });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error((data && (data.error || data.message)) || "Failed to load");
      setRows(Array.isArray(data?.rows) ? data.rows : []);
    } catch (e: any) {
      setError(e?.message || "Failed to load");
    } finally {
      setLoading(false);
    }
  }

  async function refreshDrivers() {
    setDriversError(null);
    try {
      const res = await fetch("/api/dispatch/drivers", { cache: "no-store" });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error((data && (data.error || data.message)) || ("HTTP " + res.status));
      const list = Array.isArray(data?.drivers) ? data.drivers : [];
      setDrivers(list);
    } catch (e: any) {
      setDrivers([]);
      setDriversError(e?.message || "Failed to load drivers");
    }
  }

  function pickSuggestedDriverId(b: Booking): string {
    return pickNearestEligibleDriverId(b, drivers, forceAssign);
  }

  // Keep dropdown pre-selected safely (single hook, no hooks inside map)
  React.useEffect(() => {
    setSelectedDriverByBookingId((prev) => {
      let changed = false;
      const next: Record<string, string> = { ...prev };

      for (const b of rows) {
        const bookingId = String(b.id);
        const alreadyAssigned = !!b.driver_id;
        if (alreadyAssigned) continue;
        if (next[bookingId]) continue;

        const suggested = pickSuggestedDriverId(b);
        if (suggested) {
          next[bookingId] = suggested;
          changed = true;
        }
      }

      return changed ? next : prev;
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [rows, drivers, forceAssign]);

  function getBookingCodeById(bookingId: string): string {
    const row = rows.find((x) => String(x.id) === String(bookingId));
    const code = String(row?.booking_code || "").trim();
    return code;
  }

  async function assignDirect(bookingId: string, driverId: string) {
    if (!driverId) return;

    const bookingCode = getBookingCodeById(bookingId);
    if (!bookingCode) {
      setError("Assign failed: booking_code missing for this row. Reload and try again.");
      return;
    }

    setError(null);
    setPending(bookingId, true);
    try {
      const res = await fetch("/api/dispatch/assign", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bookingCode, driverId }),
      });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error((data && (data.error || data.message)) || "Assign failed");

      // Optimistic UI update, then refresh from server to stay consistent
      setRows((prev) => prev.map((x) => (String(x.id) === String(bookingId) ? { ...x, driver_id: driverId } : x)));

      setSelectedDriverByBookingId((prev) => {
        const next = { ...prev };
        delete next[bookingId];
        return next;
      });

      await load();
    } catch (e: any) {
      setError(e?.message || "Assign failed");
    } finally {
      setPending(bookingId, false);
    }
  }

  async function assign(bookingId: string) {
    const driverId = selectedDriverByBookingId[bookingId] || "";
    if (!driverId) return;
    return assignDirect(bookingId, driverId);
  }

  async function createBooking() {
    setError(null);
    try {
      const payload: any = {};

      if (serviceType === "takeout") {
        payload.service_type = "takeout";
        payload.takeout_service_level = takeoutLevel;
        payload.vendor_id = vendorId || null;
        payload.pickup_label = pickupLabel || null;
        payload.dropoff_label = dropoffLabel || null;
        payload.town = town || "";
      } else {
        payload.service_type = "dispatch";
        payload.rider_name = riderName;
        payload.rider_phone = riderPhone;
        payload.town = town;
        payload.pickup_lat = pickupLat ? Number(pickupLat) : null;
        payload.pickup_lng = pickupLng ? Number(pickupLng) : null;
      }

      const res = await fetch("/api/dispatch/bookings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error((data && (data.error || data.message)) || "Failed to create");

      const newRow: Booking = data?.row;
      if (!newRow?.id) throw new Error("Create returned no row/id");

      setRows((prev) => [newRow, ...prev]);

      // reset fields
      setRiderName("");
      setRiderPhone("");
      setTown("");
      setPickupLat("");
      setPickupLng("");
      setVendorId("");
      setTakeoutLevel("regular");
      setPickupLabel("");
      setDropoffLabel("");

      // auto-assign immediately (only if enabled and unassigned)
      if (autoAssignOnCreate && !newRow.driver_id) {
        if (!drivers.length) await refreshDrivers();

        const suggested = pickNearestEligibleDriverId(newRow, drivers.length ? drivers : [], forceAssign);
        if (suggested) {
          await assignDirect(String(newRow.id), suggested);
        } else {
          setError("Created booking, but no eligible drivers for its town.");
        }
      }
    } catch (e: any) {
      setError(e?.message || "Failed to create");
    }
  }

  async function setStatus(b: Booking, status: string) {
    const booking_id = String(b.id);
    setError(null);
    setPending(booking_id, true);

    const bookingId = isShortId(b.id) ? undefined : b.id;

    try {
      const res = await fetch("/api/dispatch/status", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bookingId, booking_id, status }),
      });
      const data = await res.json().catch(() => null);
      if (!res.ok) throw new Error((data && (data.error || data.message)) || "Update failed");

      setRows((prev) => prev.map((x) => (String(x.id) === String(booking_id) ? data.row : x)));
    } catch (e: any) {
      setError(e?.message || "Update failed");
    } finally {
      setPending(booking_id, false);
    }
  }

  React.useEffect(() => {
    load();
    refreshDrivers();
  }, []);

  React.useEffect(() => {
    const t = window.setInterval(() => {
      refreshDrivers();
    }, 15000);
    return () => window.clearInterval(t);
  }, []);

  return (
    <div className="p-6 space-y-8">
      <div className="flex items-center justify-between gap-4">
        <h1 className="text-2xl font-semibold">Dispatch Panel</h1>

        <div className="flex items-center gap-6">
          <label className="inline-flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={forceAssign}
              onChange={(e) => setForceAssign(e.target.checked)}
            />
            <span>Force assign (ignore online preference)</span>
          </label>

          <label className="inline-flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              checked={autoAssignOnCreate}
              onChange={(e) => setAutoAssignOnCreate(e.target.checked)}
            />
            <span>Auto-assign on create</span>
          </label>
        </div>
      </div>

      <div className="rounded-2xl border p-4 shadow space-y-3">
        <h2 className="font-medium">New Booking</h2>

        <div className="flex gap-3 items-center">
          <label className="text-sm">Type</label>
          <select
            className="border rounded px-3 py-2"
            value={serviceType}
            onChange={(e) => setServiceType(e.target.value as any)}
          >
            <option value="dispatch">Dispatch (local)</option>
            <option value="takeout">Takeout</option>
          </select>

          {serviceType === "takeout" ? (
            <>
              <label className="text-sm">Takeout</label>
              <select
                className="border rounded px-3 py-2"
                value={takeoutLevel}
                onChange={(e) => setTakeoutLevel(e.target.value as any)}
                title="Regular = with waiting, Express = OTC/no waiting"
              >
                <option value="regular">Regular (PHP 70 min)</option>
                <option value="express">Express / OTC (PHP 55 min)</option>
              </select>
            </>
          ) : null}
        </div>

        {serviceType === "takeout" ? (
          <div className="grid md:grid-cols-5 gap-3">
            <input className="border rounded px-3 py-2" placeholder="Town (optional)" value={town} onChange={(e) => setTown(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="vendor_id (UUID)" value={vendorId} onChange={(e) => setVendorId(e.target.value)} />
            <input className="border rounded px-3 py-2 md:col-span-2" placeholder="Pickup label (Vendor pickup)" value={pickupLabel} onChange={(e) => setPickupLabel(e.target.value)} />
            <input className="border rounded px-3 py-2 md:col-span-2" placeholder="Dropoff label (Customer dropoff)" value={dropoffLabel} onChange={(e) => setDropoffLabel(e.target.value)} />
          </div>
        ) : (
          <div className="grid md:grid-cols-5 gap-3">
            <input className="border rounded px-3 py-2" placeholder="Rider name" value={riderName} onChange={(e) => setRiderName(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Rider phone" value={riderPhone} onChange={(e) => setRiderPhone(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Town" value={town} onChange={(e) => setTown(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Pickup lat" value={pickupLat} onChange={(e) => setPickupLat(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Pickup lng" value={pickupLng} onChange={(e) => setPickupLng(e.target.value)} />
          </div>
        )}

        <button onClick={createBooking} className="px-4 py-2 rounded-xl border shadow">Create</button>
        {error ? <p className="text-red-600">{error}</p> : null}
      </div>

      <div className="rounded-2xl border p-4 shadow">
        <div className="flex items-center justify-between gap-3">
          <h2 className="font-medium mb-3">Queue</h2>

          <div className="text-xs text-gray-600 flex items-center gap-3">
            <button className="px-3 py-1 rounded border" onClick={refreshDrivers}>Refresh drivers</button>
            {driversError ? <span className="text-red-600">{driversError}</span> : null}
          </div>
        </div>

        {loading ? <p>Loading...</p> : rows.length === 0 ? <p>No active rides.</p> : (
          <table className="w-full text-sm">
            <thead>
              <tr className="text-left border-b">
                <th className="py-2">ID</th>
                <th className="py-2">Town</th>
                <th className="py-2">Status</th>
                <th className="py-2">Driver</th>
                <th className="py-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {rows.map((b) => {
                const bookingId = String(b.id);
                const alreadyAssigned = !!b.driver_id;
                const isTerminal = ["completed", "canceled", "cancelled"].includes(String(b.status || "").toLowerCase());

                const townKey = normTown(b.town);
                const townDrivers = drivers.filter((d) => normTown(d.town) === townKey);

                const onlineDrivers = townDrivers.filter((d) => isOnlineLike(d.status));
                const busyDrivers = townDrivers.filter((d) => !isOnlineLike(d.status));

                const eligibleDrivers = forceAssign ? townDrivers : onlineDrivers;
                const suggestedDriverId = pickSuggestedDriverId(b);

                const selected = selectedDriverByBookingId[bookingId] || "";
                const pending = !!pendingByBookingId[bookingId];

                return (
                  <tr key={bookingId} className="border-b">
                    <td className="py-2">{bookingId.slice(0, 8)}</td>
                    <td className="py-2">{b.town || ""}</td>
                    <td className="py-2">{b.status || ""}</td>
                    <td className="py-2">{b.driver_id ? b.driver_id : "-"}</td>
                    <td className="py-2 space-x-2">
                      {!alreadyAssigned ? (
                        <>
                          <select
                            className="border rounded px-2 py-1 w-56"
                            value={selected}
                            onChange={(e) => setSelectedDriverByBookingId((prev) => ({ ...prev, [bookingId]: e.target.value }))}
                            disabled={pending}
                            title="Same-town drivers only. Force assign uses all same-town; otherwise online-only. Suggested uses nearest by pickup coords."
                          >
                            {eligibleDrivers.length === 0 ? (
                              <option value="">No eligible drivers</option>
                            ) : (
                              eligibleDrivers.map((d) => {
                                const tag = isOnlineLike(d.status) ? "online" : "busy";
                                return (
                                  <option key={d.id} value={d.id}>
                                    {d.id.slice(0, 8)} ({tag})
                                  </option>
                                );
                              })
                            )}
                          </select>

                          <span className="text-xs text-gray-600 ml-2">
                            Online {onlineDrivers.length} / Busy {busyDrivers.length}
                          </span>

                          <button
                            onClick={() => assign(bookingId)}
                            className="px-2 py-1 rounded border"
                            disabled={pending || !selected || eligibleDrivers.length === 0}
                            title={!selected ? "Select a driver first" : ""}
                          >
                            Assign
                          </button>

                          <button
                            onClick={() => suggestedDriverId && assignDirect(bookingId, suggestedDriverId)}
                            className="px-2 py-1 rounded border"
                            disabled={pending || !suggestedDriverId}
                            title={!suggestedDriverId ? "No suggested driver available" : "Assign nearest eligible driver"}
                          >
                            Assign suggested
                          </button>
                        </>
                      ) : null}

                      <button
                        onClick={() => setStatus(b, "enroute")}
                        className="px-2 py-1 rounded border"
                        disabled={pending || isTerminal}
                      >
                        En-route
                      </button>

                      <button
                        onClick={() => setStatus(b, "arrived")}
                        className="px-2 py-1 rounded border"
                        disabled={pending || isTerminal}
                      >
                        Arrived
                      </button>

                      <button
                        onClick={() => setStatus(b, "completed")}
                        className="px-2 py-1 rounded border"
                        disabled={pending || isTerminal}
                      >
                        Complete
                      </button>

                      <button
                        onClick={() => setStatus(b, "canceled")}
                        className="px-2 py-1 rounded border"
                        disabled={pending || isTerminal}
                      >
                        Cancel
                      </button>

                      {pending ? <span className="text-xs text-gray-500 ml-2">Updating...</span> : null}
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        )}
      </div>
    </div>
  );
}
