"use client";


function isShortId(v: any) {
  const s = String(v ?? "");
  // UUIDs are 36 chars; our "short" table IDs are usually 6-8 chars
  return s.length > 0 && s.length < 20;
}
import * as React from "react";

type Booking = {
  id: string;
  rider_name: string | null;
  rider_phone: string | null;

  // optional labels used by takeout flows
  pickup_label?: string | null;
  dropoff_label?: string | null;

  pickup_lat: number; pickup_lng: number;
  dropoff_lat: number | null; dropoff_lng: number | null;

  town: string;
  distance_km: number | null;
  fare: number | null;
  status: "requested"|"assigned"|"enroute"|"arrived"|"completed"|"canceled";
  driver_id: string | null;
  created_at: string; updated_at: string;

  // optional takeout fields (may exist on API response)
  service_type?: string | null;
  trip_type?: string | null;
  vendor_id?: string | null;
  takeout_service_level?: "regular" | "express" | null;
};

export default function DispatchPage(): JSX.Element {
  const [rows, setRows] = React.useState<Booking[]>([]);
  const [pendingById, setPendingById] = React.useState<Record<string, string | null>>({});
const btnClass = (disabled: boolean) =>
  "px-3 py-1 border rounded " + (disabled ? "opacity-50 cursor-not-allowed" : "");
const normStatus = (s: string) => {
  const map: Record<string, string> = {
    enroute: "on_the_way",
    "en-route": "on_the_way",
    en_route: "on_the_way",
    cancel: "cancelled",
    canceled: "cancelled",
  };
  return map[s] ?? s;
};
const order: Record<string, number> = {
  new: 0,
  pending: 0,
  assigned: 1,
  on_the_way: 2,
  arrived: 3,
  completed: 4,
  cancelled: 5,
  canceled: 5,
};
const reached = (cur: any, target: any) =>
  (order[String(cur ?? "")] ?? -1) >= (order[String(target ?? "")] ?? -1);


// ----- Driver helpers -----
function normTown(v: any) {
  return String(v ?? "").trim().toLowerCase();
}
function getDriverId(d: any): string {
  return String(d?.id ?? d?.driver_id ?? d?.driverId ?? d?.uuid ?? "");
}
function getDriverTown(d: any): string {
  // try common shapes
  return String(d?.town ?? d?.zone ?? d?.home_town ?? d?.homeTown ?? "");
}
function getDriverLabel(d: any): string {
  const name = String(d?.name ?? d?.driver_name ?? d?.full_name ?? d?.fullName ?? "").trim();
  const id = getDriverId(d);
  if (name) return name;
  if (id) return "Driver " + id.slice(0, 6);
  return "Driver";
}
function isDriverOnline(d: any): boolean {
  const s = String(d?.status ?? d?.state ?? d?.availability ?? "").toLowerCase();
  if (!s) return true; // if unknown, treat as available (safe for UI listing)
  return ["online", "available", "active"].includes(s);
}

// Load drivers from existing admin livetrips page-data (data-only; we do NOT touch LiveTrips UI)
async function refreshDrivers() {
  try {
    setDriversError(null);
    const res = await fetch("/api/admin/livetrips/page-data?debug=1", { cache: "no-store" as any });
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(t || ("HTTP_" + res.status));
    }
    const j: any = await res.json().catch(() => ({}));
    const candidates = [
      j?.drivers,
      j?.driver_locations,
      j?.driverLocations,
      j?.onlineDrivers,
      j?.data?.drivers,
    ];
    let arr: any[] = [];
    for (const c of candidates) {
      if (Array.isArray(c) && c.length) { arr = c; break; }
    }
    // keep only items with an id
    const cleaned = (arr || []).filter((d) => !!getDriverId(d)).filter(isDriverOnline);
    setDrivers(cleaned);
  } catch (e: any) {
    // If this fails (auth, route missing), we fall back to manual UUID input per row.
    setDrivers([]);
    setDriversError(e?.message || "DRIVERS_LOAD_FAILED");
  }
}

// Refresh drivers every 10s (independent of bookings refresh)
async function refreshRows() {
  try {
    const res = await fetch("/api/dispatch/bookings", { cache: "no-store" as any });
    const data = await res.json().catch(() => null);

    // Accept multiple shapes:
    // - array
    // - { rows: [...] }
    // - { data: [...] }
    // - { ok: true, rows: [...] }
    const rows =
      Array.isArray(data) ? data :
      (data && Array.isArray(data.rows) ? data.rows :
      (data && Array.isArray(data.data) ? data.data :
      (data && data.ok && Array.isArray(data.rows) ? data.rows : null)));

    if (rows) setRows(rows as any);
  } catch (e) {
    // silent refresh; no UI disruption
    console.debug("refreshRows failed", e);
  }
}

// Auto-refresh every 5s
React.useEffect(() => {
  const id = setInterval(() => { refreshRows(); }, 5000);
  return () => clearInterval(id);
}, []);const [loading, setLoading] = React.useState<boolean>(true);
  const [error, setError] = React.useState<string | null>(null);

  // create form
  const [serviceType, setServiceType] = React.useState<"dispatch" | "takeout">("dispatch");

  // dispatch/local fields
  const [riderName, setRiderName] = React.useState<string>("");
  const [riderPhone, setRiderPhone] = React.useState<string>("");
  const [town, setTown] = React.useState<string>("");
  const [pickupLat, setPickupLat] = React.useState<string>("");
  const [pickupLng, setPickupLng] = React.useState<string>("");

  // takeout fields
  const [vendorId, setVendorId] = React.useState<string>("");
  const [takeoutLevel, setTakeoutLevel] = React.useState<"regular" | "express">("regular");
  const [pickupLabel, setPickupLabel] = React.useState<string>("");
  const [dropoffLabel, setDropoffLabel] = React.useState<string>("");
  // ---- Dispatch assign UX (Grab/Uber style): suggested + dropdown fallback ----
  const [drivers, setDrivers] = React.useState<any[]>([]);
  const [driversError, setDriversError] = React.useState<string | null>(null);

  // selected driver per booking row (manual dropdown selection)
  const [selectedDriverByBookingId, setSelectedDriverByBookingId] = React.useState<Record<string, string>>({});

  // suggested driver per booking row (auto suggestion)
  const [suggestedDriverByBookingId, setSuggestedDriverByBookingId] = React.useState<Record<string, string>>({});

  // manual fallback per booking row (only used if we can't load drivers list)
  const [manualDriverByBookingId, setManualDriverByBookingId] = React.useState<Record<string, string>>({});

React.useEffect(() => {
  refreshDrivers();
  const id = setInterval(() => { refreshDrivers(); }, 10000);
  return () => clearInterval(id);
}, []);

// Compute suggested drivers whenever rows/drivers change
React.useEffect(() => {
  // busy drivers = assigned to any active trip in the queue
  const busy = new Set<string>();
  for (const r of rows as any[]) {
    const did = String((r as any)?.driver_id ?? "");
    const st = String((r as any)?.status ?? "");
    if (did && reached(st, "assigned") && !reached(st, "completed") && !reached(st, "cancelled")) {
      busy.add(did);
    }
  }

  const next: Record<string, string> = {};

  for (const b of rows as any[]) {
    const bid = String(b?.id ?? "");
    if (!bid) continue;

    // Only suggest if not already assigned and not terminal
    if (b?.driver_id) { continue; }
    const st = String(b?.status ?? "");
    if (reached(st, "completed") || reached(st, "cancelled")) continue;

    const townKey = normTown(b?.town);
    // eligible drivers: online + not busy; prefer same town if driver has town
    const eligible = (drivers || [])
      .filter((d) => {
        const did = getDriverId(d);
        if (!did) return false;
        if (busy.has(did)) return false;
        return true;
      })
      .sort((a, b2) => {
        const at = normTown(getDriverTown(a));
        const bt = normTown(getDriverTown(b2));
        const aSame = townKey && at && at === townKey ? 0 : 1;
        const bSame = townKey && bt && bt === townKey ? 0 : 1;
        if (aSame !== bSame) return aSame - bSame;
        // stable tie-break: id
        return getDriverId(a).localeCompare(getDriverId(b2));
      });

    if (eligible.length) {
      next[bid] = getDriverId(eligible[0]);
    }
  }

  setSuggestedDriverByBookingId(next);
}, [rows, drivers]);

async function load() {
    setLoading(true); setError(null);
    try {
      const res = await fetch("/api/dispatch/bookings", { cache: "no-store" });
      const data = await res.json();
      if (!res.ok) throw new Error((data && data.error) || "Failed to load");
      setRows(Array.isArray(data.rows) ? data.rows : []);
    } catch (e: any) { setError(e?.message || "Failed to load"); }
    finally { setLoading(false); }
  }

  async function createBooking() {
    setError(null);
    try {
      const payload: any = {};

      if (serviceType === "takeout") {
        // TAKEOUT create (Express/Regular)
        payload.service_type = "takeout";
        payload.takeout_service_level = takeoutLevel; // "regular" | "express"
        payload.vendor_id = vendorId || null;

        // labels (your takeout UI uses labels; coords can be null)
        payload.pickup_label = pickupLabel || null;
        payload.dropoff_label = dropoffLabel || null;

        // keep town if provided (optional)
        payload.town = town || "";
      } else {
        // DISPATCH/local create (existing behavior)
        payload.rider_name = riderName;
        payload.rider_phone = riderPhone;
        payload.town = town;
        payload.pickup_lat = Number(pickupLat);
        payload.pickup_lng = Number(pickupLng);
      }

      const res = await fetch("/api/dispatch/bookings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const data = await res.json();
      if (!res.ok) throw new Error((data && data.error) || "Failed to create");

      setRows((prev) => [data.row, ...prev]);

      // reset fields (keep serviceType selection)
      setRiderName(""); setRiderPhone(""); setTown(""); setPickupLat(""); setPickupLng("");
      setVendorId(""); setTakeoutLevel("regular"); setPickupLabel(""); setDropoffLabel("");
    } catch (e: any) { setError(e?.message || "Failed to create"); }
  }

  async function assign(booking_id: string, explicitDriverId?: string) {
    const chosen =
      String(explicitDriverId ?? "") ||
      String(selectedDriverByBookingId[booking_id] ?? "") ||
      String(suggestedDriverByBookingId[booking_id] ?? "") ||
      String(manualDriverByBookingId[booking_id] ?? "");

    if (!chosen) return;

    // lock row buttons while assigning
    setPendingById((p) => ({ ...p, [booking_id]: "assigning" }));

    try {
      const res = await fetch("/api/dispatch/assign", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ booking_id, driver_id: chosen }),
      });

      const data = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error((data && (data.error || data.message)) || "Assign failed");

      if (data && data.row) {
        setRows((prev) => prev.map((b) => (b.id === booking_id ? data.row : b)));
      } else {
        await refreshRows();
      }

      // clear manual selection after success
      setSelectedDriverByBookingId((m) => ({ ...m, [booking_id]: "" }));
      setManualDriverByBookingId((m) => ({ ...m, [booking_id]: "" }));
    } catch (e: any) {
      setError(e?.message || "Assign failed");
    } finally {
      setPendingById((p) => ({ ...p, [booking_id]: null }));
    }
  }
  async function setStatus(booking_id: string, status: string) {
  const apiStatus = normStatus(status);

  // Disable buttons for this row while request is in flight
  setPendingById((p) => ({ ...p, [booking_id]: apiStatus }));

  // Optimistic UI: update row status immediately
  setRows((prev) =>
    prev.map((b: any) => (b.id === booking_id ? { ...b, status: apiStatus } : b))
  );

  try {
    const res = await fetch("/api/dispatch/status", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ bookingId: booking_id, status: apiStatus }),
    });

    const t = await res.text();

    if (!res.ok) {
      console.error("Dispatch status update failed:", t);
      alert("Failed to update trip status: " + t);
      return;
    }

    // If API returns a row, prefer it; otherwise keep optimistic status
    try {
      const data = JSON.parse(t);
      if (data && data.row) {
        setRows((prev) => prev.map((b: any) => (b.id === booking_id ? data.row : b)));
      }
    } catch (_) {
      // non-JSON OK response; ignore
    }
  } catch (e: any) {
    console.error(e);
    alert("Failed to update trip status");
  } finally {
    await refreshRows();
    setPendingById((p) => ({ ...p, [booking_id]: null }));
  }
}

  React.useEffect(function(){ load(); }, []);

  return (
    <div className="p-6 space-y-8">
      <h1 className="text-2xl font-semibold">Dispatch Panel</h1>

      <div className="rounded-2xl border p-4 shadow space-y-3">
        <h2 className="font-medium">New Booking</h2>

        <div className="flex gap-3 items-center">
          <label className="text-sm">Type</label>
          <select
            className="border rounded px-3 py-2"
            value={serviceType}
            onChange={(e)=>setServiceType(e.target.value as any)}
          >
            <option value="dispatch">Dispatch (local)</option>
            <option value="takeout">Takeout</option>
          </select>

          {serviceType === "takeout" ? (
            <>
              <label className="text-sm">Takeout</label>
              <select
                className="border rounded px-3 py-2"
                value={takeoutLevel}
                onChange={(e)=>setTakeoutLevel(e.target.value as any)}
                title="Regular = with waiting, Express = OTC/no waiting"
              >
                <option value="regular">Regular (â‚±70 min)</option>
                <option value="express">Express / OTC (â‚±55 min)</option>
              </select>
            </>
          ) : null}
        </div>

        {serviceType === "takeout" ? (
          <div className="grid md:grid-cols-5 gap-3">
            <input className="border rounded px-3 py-2" placeholder="Town (optional)" value={town} onChange={(e)=>setTown(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="vendor_id (UUID)" value={vendorId} onChange={(e)=>setVendorId(e.target.value)} />
            <input className="border rounded px-3 py-2 md:col-span-2" placeholder="Pickup label (Vendor pickup)" value={pickupLabel} onChange={(e)=>setPickupLabel(e.target.value)} />
            <input className="border rounded px-3 py-2 md:col-span-2" placeholder="Dropoff label (Customer dropoff)" value={dropoffLabel} onChange={(e)=>setDropoffLabel(e.target.value)} />
          </div>
        ) : (
          <div className="grid md:grid-cols-5 gap-3">
            <input className="border rounded px-3 py-2" placeholder="Rider name" value={riderName} onChange={(e)=>setRiderName(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Rider phone" value={riderPhone} onChange={(e)=>setRiderPhone(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Town" value={town} onChange={(e)=>setTown(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Pickup lat" value={pickupLat} onChange={(e)=>setPickupLat(e.target.value)} />
            <input className="border rounded px-3 py-2" placeholder="Pickup lng" value={pickupLng} onChange={(e)=>setPickupLng(e.target.value)} />
          </div>
        )}

        <button onClick={createBooking} className="px-4 py-2 rounded-xl border shadow">Create</button>
        {error ? <p className="text-red-600">{error}</p> : null}
      </div>

      <div className="rounded-2xl border p-4 shadow">
        <h2 className="font-medium mb-3">Queue</h2>
        {loading ? <p>Loading...</p> : rows.length === 0 ? <p>No active rides.</p> : (
          <table className="w-full text-sm">
            <thead>
              <tr className="text-left border-b">
                <th className="py-2">ID</th>
                <th className="py-2">Town</th>
                <th className="py-2">Status</th>
                <th className="py-2">Driver</th>
                <th className="py-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {rows.map(function(b){
                return (
                  <tr key={b.id} className="border-b">
                    <td className="py-2">{b.id.slice(0,8)}</td>
                    <td className="py-2">{b.town}</td>
                    <td className="py-2">{b.status}</td>
                    <td className="py-2">{b.driver_id ? b.driver_id : "-"}</td>
                    <td className="py-2 space-x-2">
  {/* Suggested + dropdown assign (dispatcher-friendly) */}
  {(() => {
    const pending = !!pendingById[b.id];
    const isTerminal = reached(b.status, "completed") || reached(b.status, "cancelled");
    const alreadyAssigned = !!b.driver_id;

    const suggestedId = suggestedDriverByBookingId[b.id] || "";
    const selectedId = selectedDriverByBookingId[b.id] || "";
    const manualId = manualDriverByBookingId[b.id] || "";

    // busy drivers are filtered in suggestion effect; dropdown filters again defensively
    const busy = new Set<string>();
    for (const r of rows as any[]) {
      const did = String((r as any)?.driver_id ?? "");
      const st = String((r as any)?.status ?? "");
      if (did && reached(st, "assigned") && !reached(st, "completed") && !reached(st, "cancelled")) busy.add(did);
    }

    const eligibleDrivers = (drivers || []).filter((d) => {
      const did = String(getDriverId(d) || "");
      if (!did) return false;
      if (busy.has(did)) return false;
      // town preference: allow all, but move same-town to top via sort below
      return true;
    }).sort((a, b2) => {
      const townKey = normTown(b.town);
      const at = normTown(getDriverTown(a));
      const bt = normTown(getDriverTown(b2));
      const aSame = townKey && at && at === townKey ? 0 : 1;
      const bSame = townKey && bt && bt === townKey ? 0 : 1;
      if (aSame !== bSame) return aSame - bSame;
      return getDriverId(a).localeCompare(getDriverId(b2));
    });

    const canAssignSuggested = !pending && !isTerminal && !alreadyAssigned && !!suggestedId;
    const canAssignSelected = !pending && !isTerminal && !alreadyAssigned && !!(selectedId || manualId);

    return (
      <>
        {driversError ? (
          <span className="text-xs text-amber-700 mr-2" title={driversError}>
            Drivers list unavailable (manual UUID)
          </span>
        ) : null}

        {!alreadyAssigned && suggestedId ? (
          <span className="text-xs mr-2">
            Suggested: <span className="font-mono">{suggestedId.slice(0, 6)}</span>
          </span>
        ) : null}

        {!alreadyAssigned ? (
          eligibleDrivers.length ? (
            <select
              className="border rounded px-2 py-1"
              value={selectedId}
              onChange={(e) => setSelectedDriverByBookingId((m) => ({ ...m, [b.id]: e.target.value }))}
              disabled={pending || isTerminal}
              title="Select driver (eligible only)"
            >
              <option value="">Select driver...</option>
              {eligibleDrivers.map((d: any) => {
                const id = getDriverId(d);
                return (
                  <option key={id} value={id}>
                    {getDriverLabel(d)} ({id.slice(0, 6)}){getDriverTown(d) ? " - " + getDriverTown(d) : ""}
                  </option>
                );
              })}
            </select>
          ) : (
            <input
              className="border rounded px-2 py-1 w-44"
              placeholder="driver_id (UUID)"
              value={manualId}
              onChange={(e) => setManualDriverByBookingId((m) => ({ ...m, [b.id]: e.target.value }))}
              disabled={pending || isTerminal}
            />
          )
        ) : null}

        <button
          disabled={!canAssignSuggested}
          onClick={() => assign(b.id, suggestedId)}
          className={btnClass(!canAssignSuggested)}
          title={!suggestedId ? "No suggested driver" : "Assign suggested driver"}
        >
          Assign suggested
        </button>

        <button
          disabled={!canAssignSelected}
          onClick={() => assign(b.id)}
          className={btnClass(!canAssignSelected)}
          title="Assign selected/manual driver"
        >
          Assign
        </button>

        <button
          disabled={!!pendingById[b.id] || !b.driver_id || !reached(b.status,"assigned") || reached(b.status,"on_the_way")}
          onClick={()=>setStatus(b.id,"enroute")}
          className={btnClass(!!pendingById[b.id] || reached(b.status, "on_the_way"))}
        >
          En-route
        </button>

        <button
          disabled={!!pendingById[b.id] || !b.driver_id || !reached(b.status,"on_the_way") || reached(b.status,"arrived")}
          onClick={()=>setStatus(b.id,"arrived")}
          className={btnClass(!!pendingById[b.id] || reached(b.status, "arrived"))}
        >
          Arrived
        </button>

        <button
          disabled={!!pendingById[b.id] || !b.driver_id || !reached(b.status,"arrived") || reached(b.status,"completed")}
          onClick={()=>setStatus(b.id,"completed")}
          className={btnClass(!!pendingById[b.id] || reached(b.status, "completed"))}
        >
          Complete
        </button>

        <button
          disabled={!!pendingById[b.id] || reached(b.status,"completed") || reached(b.status,"cancelled")}
          onClick={()=>setStatus(b.id,"canceled")}
          className={btnClass(!!pendingById[b.id] || reached(b.status, "cancelled"))}
        >
          Cancel
        </button>
      </>
    );
  })()}
</td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        )}
      </div>
    </div>
  );
}











