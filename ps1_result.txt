============================================================
app\api\public\passenger\book\route.ts
------------------------------------------------------------
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";



/* PHASE2D_SNAPSHOT_HELPERS_BEGIN */
function p2dNum(v:any){ const n=Number(v??0); return Number.isFinite(n)?n:0 }
function p2dQty(v:any){ const q=parseInt(String(v??1),10); return (Number.isFinite(q) && q>0)?q:1 }
function p2dPickItemsArray(body:any): any[] {
  const cands = [body?.items, body?.cart, body?.order_items, body?.takeout_items, body?.menu_snapshot];
  for (const x of cands) if (Array.isArray(x) && x.length) return x;
  return [];
}
function p2dPickId(it:any){ return String(it?.menu_item_id || it?.menuItemId || it?.id || it?.item_id || it?.itemId || "").trim() }
function p2dPickName(it:any){ return String(it?.name || it?.title || it?.label || "").trim() }
function p2dPickPrice(it:any){ return p2dNum(it?.price ?? it?.unit_price ?? it?.unitPrice ?? it?.amount ?? 0) }

async function p2dFetchMenuRowsForVendor(admin:any, vendorId:string): Promise<any[]> {
  // best-effort: tolerate table name differences
  const tables = ["vendor_menu_items", "takeout_menu_items", "menu_items", "vendor_menu"];
  for (const t of tables) {
    try {
      let r = await admin.from(t).select("*").eq("vendor_id", vendorId).limit(2000);
      if (r?.error) r = await admin.from(t).select("*").limit(2000);
      if (!r?.error && Array.isArray(r.data)) return r.data;
    } catch {}
  }
  return [];
}
function p2dMenuById(menuRows:any[]): Record<string, any> {
  const m: Record<string, any> = {};
  for (const r of (menuRows || [])) {
    const id = String(r?.menu_item_id || r?.id || r?.item_id || r?.menuItemId || "").trim();
    if (id) m[id] = r;
  }
  return m;
}

async function p2dSnapshotTakeout(admin:any, bookingId:string, vendorId:string, body:any) {
  const itemsIn = p2dPickItemsArray(body);
  if (!bookingId || !vendorId || !itemsIn.length) return { ok:false, inserted:0, subtotal:0, note:"Missing vendor_id or items[]" };

  const menuRows = await p2dFetchMenuRowsForVendor(admin, vendorId);
  const byId = p2dMenuById(menuRows);

  const rows:any[] = [];
  let subtotal = 0;

  for (const it of itemsIn) {
    const mid = p2dPickId(it);
    const qty = p2dQty(it?.quantity ?? it?.qty ?? it?.count ?? 1);

    const mr = mid ? byId[mid] : null;
    const name = String((mr?.name ?? mr?.item_name ?? mr?.title) ?? p2dPickName(it) ?? "").trim();
    const price = p2dNum((mr?.price ?? mr?.unit_price ?? mr?.amount) ?? p2dPickPrice(it));

    if (!name) continue;

    rows.push({
      booking_id: bookingId,
      menu_item_id: mid || null,
      name,
      price,
      quantity: qty,
      snapshot_at: new Date().toISOString(),
    });

    subtotal += price * qty;
  }

  if (!rows.length) return { ok:false, inserted:0, subtotal:0, note:"No valid items to snapshot" };

  const ins = await admin.from("takeout_order_items").insert(rows);
  if (ins?.error) return { ok:false, inserted:0, subtotal:0, note:"Snapshot insert failed: " + ins.error.message };

  const up = await admin.from("bookings").update({ service_type:"takeout", takeout_items_subtotal: subtotal }).eq("id", bookingId);
  if (up?.error) return { ok:true, inserted: rows.length, subtotal, note:"Subtotal update failed: " + up.error.message };

  return { ok:true, inserted: rows.length, subtotal };
}
/* PHASE2D_SNAPSHOT_HELPERS_END */
function inIfugaoBBox(lat: number, lng: number): boolean {
  // Conservative backend geofence (matches UI)
  return lat >= 16.5 && lat <= 17.2 && lng >= 120.8 && lng <= 121.4;
}
/* JRIDE_ENV_ECHO */
function jrideEnvEcho() {
  const u = process.env.NEXT_PUBLIC_SUPABASE_URL || "";
  let host = "";
  try { host = u ? new URL(u).host : ""; } catch { host = ""; }
  return {
    supabase_host: host || null,
    vercel_env: process.env.VERCEL_ENV || null,
    nextauth_url: process.env.NEXTAUTH_URL || null
  };
}
/* JRIDE_ENV_ECHO_END */

type BookReq = {
  passenger_name?: string | null;
  town?: string | null;

  from_label?: string | null;
  to_label?: string | null;

  pickup_lat?: number | null;
  pickup_lng?: number | null;
  dropoff_lat?: number | null;
  dropoff_lng?: number | null;

  service?: string | null;
};



/* PHASE2D_ORDER_SNAPSHOT_LOCK_BEGIN */
function isTakeoutReq(body: any): boolean {
  const s = String(body?.service || body?.service_type || body?.serviceType || body?.trip_type || body?.tripType || "").toLowerCase();
  if (s.includes("takeout") || s.includes("food") || s.includes("order")) return true;
  if (body?.vendor_id || body?.vendorId) return true;
  if (Array.isArray(body?.items) && body.items.length) return true;
  if (Array.isArray(body?.cart) && body.cart.length) return true;
  if (Array.isArray(body?.order_items) && body.order_items.length) return true;
  if (Array.isArray(body?.takeout_items) && body.takeout_items.length) return true;
  return false;
}

function pickItemsArray(body: any): any[] {
  const cands = [body?.items, body?.cart, body?.order_items, body?.takeout_items, body?.menu_items];
  for (const x of cands) if (Array.isArray(x) && x.length) return x;
  return [];
}

function num(v: any): number {
  const n = Number(v ?? 0);
  return Number.isFinite(n) ? n : 0;
}

function pickId(it: any): string {
  return String(it?.menu_item_id || it?.menuItemId || it?.id || it?.item_id || it?.itemId || "").trim();
}

function pickQty(it: any): number {
  const q = parseInt(String(it?.quantity ?? it?.qty ?? it?.count ?? 1), 10);
  return Number.isFinite(q) && q > 0 ? q : 1;
}

function pickName(it: any): string {
  return String(it?.name || it?.title || it?.label || "").trim();
}

function pickPrice(it: any): number {
  return num(it?.price ?? it?.unit_price ?? it?.unitPrice ?? it?.amount ?? 0);
}

async function fetchMenuRowsForVendor(supabase: any, vendorId: string): Promise<any[]> {
  // Try likely menu tables in order; select * to survive column differences.
  const tables = ["vendor_menu_items", "takeout_menu_items", "menu_items", "vendor_menu"];
  for (const t of tables) {
    try {
      const q = supabase.from(t).select("*").limit(1000);
      // try filter if vendor column exists (best effort)
      let r = await q.eq("vendor_id", vendorId);
      if (r?.error) {
        r = await supabase.from(t).select("*").limit(1000); // fallback no filter
      }
      if (!r?.error && Array.isArray(r.data)) return r.data;
    } catch {}
  }
  return [];
}

function mapMenuById(menuRows: any[]): Record<string, any> {
  const m: Record<string, any> = {};
  for (const r of (menuRows || [])) {
    const id =
      String(r?.menu_item_id || r?.id || r?.item_id || r?.menuItemId || "").trim();
    if (id) m[id] = r;
  }
  return m;
}

async function snapshotTakeoutOrNull(supabase: any, bookingId: string, body: any): Promise<{ ok: boolean; subtotal: number; inserted: number; note?: string }> {
  const vendorId = String(body?.vendor_id || body?.vendorId || "").trim();
  const itemsIn = pickItemsArray(body);
  if (!vendorId || !itemsIn.length) return { ok: false, subtotal: 0, inserted: 0, note: "Missing vendor_id or items[]" };

  const menuRows = await fetchMenuRowsForVendor(supabase, vendorId);
  const byId = mapMenuById(menuRows);

  const rows: any[] = [];
  let subtotal = 0;

  for (const it of itemsIn) {
    const mid = pickId(it);
    const qty = pickQty(it);

    const mr = mid ? byId[mid] : null;
    const name = String((mr?.name ?? mr?.item_name ?? mr?.title) ?? pickName(it) ?? "").trim();
    const price = num((mr?.price ?? mr?.unit_price ?? mr?.amount) ?? pickPrice(it) ?? 0);

    if (!name || !Number.isFinite(price)) continue;

    rows.push({
      booking_id: bookingId,
      menu_item_id: mid || null,
      name,
      price,
      quantity: qty,
      snapshot_at: new Date().toISOString(),
    });

    subtotal += price * qty;
  }

  if (!rows.length) return { ok: false, subtotal: 0, inserted: 0, note: "No valid items to snapshot" };

  const ins = await supabase.from("takeout_order_items").insert(rows);
  if (ins?.error) return { ok: false, subtotal: 0, inserted: 0, note: "Insert snapshot failed: " + ins.error.message };

  const up = await supabase.from("bookings").update({ takeout_items_subtotal: subtotal }).eq("id", bookingId);
  if (up?.error) return { ok: true, subtotal, inserted: rows.length, note: "Subtotal update failed: " + up.error.message };

  return { ok: true, subtotal, inserted: rows.length };
}
/* PHASE2D_ORDER_SNAPSHOT_LOCK_END */
function codeNow() {
  const d = new Date();
  const pad = (n: number) => String(n).padStart(2, "0");
  const y = d.getFullYear();
  const m = pad(d.getMonth() + 1);
  const day = pad(d.getDate());
  const hh = pad(d.getHours());
  const mm = pad(d.getMinutes());
  const ss = pad(d.getSeconds());
  return `${y}${m}${day}${hh}${mm}${ss}`;
}

function rand4() {
  return Math.floor(Math.random() * 10000).toString().padStart(4, "0");
}

async function canBookOrThrow(supabase: ReturnType<typeof createClient>) {
  const out: any = { ok: true };

  const fmt = new Intl.DateTimeFormat("en-US", { timeZone: "Asia/Manila", hour12: false, hour: "2-digit" });
  const hour = parseInt(fmt.format(new Date()), 10);
  const nightGate = hour >= 20 || hour < 5;

  const { data: userRes } = await supabase.auth.getUser();
  const user = userRes?.user;

  let verified = false;
  if (user) {
    const email = user.email ?? null;
    const userId = user.id;
    const selV = "is_verified,verified,verification_tier";
    const tries: Array<["auth_user_id" | "user_id" | "email", string | null]> = [
      ["auth_user_id", userId],
      ["user_id", userId],
      ["email", email],
    ];

    for (const [col, val] of tries) {
      if (!val) continue;
      const r = await supabase.from("passengers").select(selV).eq(col, val).limit(1).maybeSingle();
      if (!r.error && r.data) {
        const row: any = r.data;
        const truthy = (v: any) =>
          v === true ||
          (typeof v === "string" && v.trim().toLowerCase() !== "" && v.trim().toLowerCase() !== "false") ||
          (typeof v === "number" && v > 0);
        verified = truthy(row.is_verified) || truthy(row.verified) || truthy(row.verification_tier);
        break;
      }
    }
  }

  if (nightGate && !verified) {
    out.ok = false;
    out.status = 403;
    out.code = "NIGHT_GATE_UNVERIFIED";
    out.message = "Booking is restricted from 8PM to 5AM unless verified.";
    throw out;
  }

  if (user) {
    const email = user.email ?? null;
    const userId = user.id;
    const selW = "wallet_balance,min_wallet_required,wallet_locked";
    const tries: Array<["auth_user_id" | "user_id" | "email", string | null]> = [
      ["auth_user_id", userId],
      ["user_id", userId],
      ["email", email],
    ];

    for (const [col, val] of tries) {
      if (!val) continue;
      const r = await supabase.from("passengers").select(selW).eq(col, val).limit(1).maybeSingle();
      if (r.error) break; // fail-open
      if (r.data) {
        const row: any = r.data;
        const locked = row.wallet_locked === true;
        const bal = typeof row.wallet_balance === "number" ? row.wallet_balance : null;
        const min = typeof row.min_wallet_required === "number" ? row.min_wallet_required : null;

        if (locked) {
          out.ok = false;
          out.status = 402;
          out.code = "WALLET_LOCKED";
          out.message = "Wallet is locked.";
          throw out;
        }
        if (typeof bal === "number" && typeof min === "number" && bal < min) {
          out.ok = false;
          out.status = 402;
          out.code = "WALLET_INSUFFICIENT";
          out.message = "Insufficient wallet balance.";
          throw out;
        }
        break;
      }
    }
  }

  return true;
}

async function getBaseUrlFromHeaders(req: Request) {
  const h = req.headers;
  const proto = h.get("x-forwarded-proto") || "https";
  const host = h.get("x-forwarded-host") || h.get("host") || "";
  return `${proto}://${host}`;
}

export async function POST(req: Request) {
  const supabase = createClient();
  const body = (await req.json().catch(() => ({}))) as BookReq;




  const isTakeout = isTakeoutReq(body as any);
// PHASE13-E2_BACKEND_PILOT_TOWN_GATE
  // Enforce pilot pickup towns (UI + backend parity)
  const PILOT_TOWNS = ["Lagawe", "Hingyon", "Banaue"] as const;
  const pickupTown = String((body as any)?.town || "").trim();
  const pilotTownAllowed = PILOT_TOWNS.includes(pickupTown as any);

  if (!pilotTownAllowed) {
    return NextResponse.json(
      {
        ok: false,
        code: "PILOT_TOWN_DISABLED",
        message: "Pickup in Kiangan/Lamut is temporarily unavailable during pilot.",
      },
      { status: 403 }
    );
  }

  // PHASE13-B_BACKEND_GEO_GATE
  // Booking must include location and must be inside Ifugao (conservative bbox).
  // Phase 13-C1: allow a local verification code fallback (QR/referral/admin code).
  const expectedLocal = String(process.env.JRIDE_LOCAL_VERIFY_CODE || "").trim();
  const providedLocal = String(((body as any)?.local_verification_code || (body as any)?.local_verify || "")).trim();
  const localOk = !!expectedLocal && !!providedLocal && (providedLocal === expectedLocal);

  const lat = Number((body as any)?.pickup_lat);
  const lng = Number((body as any)?.pickup_lng);
  if (!localOk && (!Number.isFinite(lat) || !Number.isFinite(lng))) {
    return NextResponse.json(
      { ok: false, code: "GEO_REQUIRED", message: "Location is required to book a ride." },
      { status: 400 }
    );
  }
  if (!localOk && Number.isFinite(lat) && Number.isFinite(lng) && !inIfugaoBBox(lat, lng)) {
    return NextResponse.json(
      { ok: false, code: "GEO_OUTSIDE_IFUGAO", message: "Booking is only allowed inside Ifugao." },
      { status: 403 }
    );
  }
  try {
    await canBookOrThrow(supabase);
  } catch (e: any) {
    return NextResponse.json(
      { ok: false, code: e.code || "CAN_BOOK_FAILED", message: e.message || "Not allowed" },
      { status: e.status || 403 }
    );
  }

  const booking_code = isTakeout
    ? `TAKEOUT-UI-${codeNow()}-${rand4()}`
    : `JR-UI-${codeNow()}-${rand4()}`;const payload: any = {
    booking_code,
    passenger_name: body.passenger_name ?? null,
    from_label: body.from_label ?? null,
    to_label: body.to_label ?? null,
    town: body.town ?? null,
    pickup_lat: body.pickup_lat ?? null,
    pickup_lng: body.pickup_lng ?? null,
    dropoff_lat: body.dropoff_lat ?? null,
    dropoff_lng: body.dropoff_lng ?? null,
    status: "requested",
  };

  /* PHASE2D_PAYLOAD_TAKEOUT_FIELDS */
  if (isTakeout) {
    const vendorId = String((body as any)?.vendor_id || (body as any)?.vendorId || "").trim();
    (payload as any).service_type = "takeout";
    (payload as any).vendor_id = vendorId || null;
    (payload as any).vendor_status = "preparing";
    (payload as any).takeout_items_subtotal = 0;
    // Optional pass-through fields if provided by UI (safe)
    (payload as any).customer_phone = (body as any)?.customer_phone ?? (body as any)?.customerPhone ?? null;
    (payload as any).delivery_address = (body as any)?.delivery_address ?? (body as any)?.deliveryAddress ?? null;
    (payload as any).note = (body as any)?.note ?? null;
  }

  const ins = await supabase.from("bookings").insert(payload).select("*").maybeSingle();
  if (ins.error) {
    const payload2: any = { ...payload };
    delete payload2.status;

    const ins2 = await supabase.from("bookings").insert(payload2).select("*").maybeSingle();
    if (ins2.error) {
      console.error("[passenger/book] insert error", ins2.error);
      return NextResponse.json({ ok: false, code: "BOOKING_INSERT_FAILED", message: ins2.error.message }, { status: 500 });
    }

    let booking: any = ins2.data;

    // best-effort set status requested
    await supabase.from("bookings").update({ status: "requested" }).eq("id", String(booking.id));

    /* PHASE2D_SKIP_ASSIGN_FOR_TAKEOUT */
    // Phase 6H2: CALL DISPATCH ASSIGN (single source of truth, includes busy lock)
    const baseUrl = await getBaseUrlFromHeaders(req);
    let assign: any = { ok: false, note: "Assignment skipped." };

    if (!isTakeout) {
      try {
        const resp = await fetch(`${baseUrl}/api/dispatch/assign`, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ booking_id: String(booking.id) }),
        });
        const j = await resp.json().catch(() => ({}));
        assign = j;
      } catch (err: any) {
        assign = { ok: false, note: "Assign call failed: " + String(err?.message || err) };
      }
    } else {
      assign = { ok: true, skipped: true, reason: "takeout_booking" };
    }
/* PHASE2D_SKIP_ASSIGN_FOR_TAKEOUT_END */// re-read booking for final status/driver_id
    const reread = await supabase.from("bookings").select("*").eq("id", String(booking.id)).maybeSingle();
    if (!reread.error && reread.data) booking = reread.data;



    /* PHASE2D_TAKEOUT_SNAPSHOT_INS2 */
    let takeoutSnapshot: any = null;
    if (isTakeout) {
      try {
        takeoutSnapshot = await snapshotTakeoutOrNull(supabase as any, String(booking.id), body as any);
      } catch (e: any) {
        takeoutSnapshot = { ok: false, note: "Snapshot threw: " + String(e?.message || e) };
      }
    }return NextResponse.json({ ok: true, env: jrideEnvEcho(), booking_code, booking, assign, takeoutSnapshot }, { status: 200 });
  }

  let booking: any = ins.data;
  // PHASE 2D: ORDER SNAPSHOT LOCK (TAKEOUT)
  // Freeze items + compute subtotal + store on booking. Menu edits won't affect history.
  try {
    const svc = String((payload as any)?.service || (payload as any)?.service_type || (payload as any)?.serviceType || "").toLowerCase();
    const isTakeout = svc.includes("takeout") || !!(payload as any)?.vendor_id || !!(payload as any)?.vendorId;
    if (isTakeout) {
      const bookingId = String((booking as any)?.id || "");
      const vendorId = String((payload as any)?.vendor_id || (payload as any)?.vendorId || "").trim();
      if (bookingId && vendorId) {
        // use same client used for insert
        const takeoutSnapshot = await p2dSnapshotTakeout(supabase as any, bookingId, vendorId, payload as any);
        // best-effort (do not fail booking)
        (booking as any).takeoutSnapshot = takeoutSnapshot;
      }
    }
  } catch (e) {
    console.error("[PHASE2D] snapshot failed", e);
  }



  /* PHASE2D_TAKEOUT_SNAPSHOT_INS1 */
  let takeoutSnapshot: any = null;
  if (isTakeout) {
    try {
      takeoutSnapshot = await snapshotTakeoutOrNull(supabase as any, String(booking.id), body as any);
    } catch (e: any) {
      takeoutSnapshot = { ok: false, note: "Snapshot threw: " + String(e?.message || e) };
    }
  }// Phase 6H2: CALL DISPATCH ASSIGN (single source of truth, includes busy lock)
  const baseUrl = await getBaseUrlFromHeaders(req);
  let assign: any = { ok: false, note: "Assignment skipped." };
  try {
    const resp = await fetch(`${baseUrl}/api/dispatch/assign`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ booking_id: String(booking.id) }),
    });
    const j = await resp.json().catch(() => ({}));
    assign = j;
  } catch (err: any) {
    assign = { ok: false, note: "Assign call failed: " + String(err?.message || err) };
  }

  // re-read booking for final status/driver_id
  const reread = await supabase.from("bookings").select("*").eq("id", String(booking.id)).maybeSingle();
  if (!reread.error && reread.data) booking = reread.data;

  return NextResponse.json({ ok: true, env: jrideEnvEcho(), booking_code, booking, assign, takeoutSnapshot }, { status: 200 });
}




============================================================
app\api\dispatch\status\route.ts
------------------------------------------------------------
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";

type StatusReq = {
  booking_id?: string | null;
  booking_code?: string | null;
  status?: string | null;
  note?: string | null;
  force?: boolean | null;
};

const ALLOWED = [
  "requested",
  "assigned",
  "on_the_way",
  "arrived",
  "enroute",
  "on_trip",
  "completed",
  "cancelled",
] as const;

const NEXT: Record<string, string[]> = {
  requested: ["assigned", "cancelled"],
  assigned: ["on_the_way", "arrived", "enroute", "cancelled"],
  on_the_way: ["arrived", "enroute", "cancelled"],
  arrived: ["on_trip", "completed", "cancelled"],
  enroute: ["arrived", "on_trip", "completed", "cancelled"],
  on_trip: ["completed", "cancelled"],
  completed: [],
  cancelled: [],
};

function norm(v: any): string {
  let s = String(v ?? "").trim().toLowerCase();
  if (!s) return "";
  s = s.replace(/[\s\-]+/g, "_");
  if (s === "new") return "requested";
  if (s === "ongoing") return "on_trip";
  return s;
}

function jsonOk(body: any, status = 200) {
return NextResponse.json(body, { status });
}

function jsonErr(code: string, message: string, status: number, extra?: any) {
return NextResponse.json(
    Object.assign({ ok: false, code, message }, extra || {}),
    { status }
  );
}

function getActorFromReq(req: Request): string {
  try {
    const h: any = (req as any)?.headers;
    const v =
      h?.get?.("x-dispatcher-id") ||
      h?.get?.("x-user-id") ||
      h?.get?.("x-admin-id") ||
      h?.get?.("x-actor") ||
      "system";
    return String(v || "system");
  } catch {
    return "system";
  }
}

async function bestEffortAudit(
  supabase: ReturnType<typeof createClient>,
  entry: {
    booking_id?: string | null;
    booking_code?: string | null;
    from_status?: string | null;
    to_status?: string | null;
    actor?: string | null;
    source?: string | null;
  }
): Promise<{ warning?: string }> {
  const payload: any = {
    booking_id: entry.booking_id ?? null,
    booking_code: entry.booking_code ?? null,
    from_status: entry.from_status ?? null,
    to_status: entry.to_status ?? null,
    actor: entry.actor ?? "system",
    source: entry.source ?? "dispatch/status",
    created_at: new Date().toISOString(),
  };

  const tables = ["dispatch_audit_log", "audit_log", "status_audit"];

  for (let i = 0; i < tables.length; i++) {
    const tbl = tables[i];
    try {
      const r: any = await supabase.from(tbl).insert(payload);
      if (!r?.error) return {};
    } catch {}
  }
  return { warning: "AUDIT_LOG_INSERT_FAILED" };
}

async function fetchBooking(
  supabase: ReturnType<typeof createClient>,
  booking_id?: string | null,
  booking_code?: string | null
): Promise<{ data: any | null; error: string | null }> {
  try {
    if (booking_id) {
      const r = await supabase
        .from("bookings")
        .select("*, pickup_lat, pickup_lng, dropoff_lat, dropoff_lng, town, vehicle_type, verified_fare")
        .eq("id", booking_id)
        .maybeSingle();
      return { data: r.data ?? null, error: r.error?.message || null };
    }
    if (booking_code) {
      const r = await supabase
        .from("bookings")
        .select("*")
        .eq("booking_code", booking_code)
        .maybeSingle();
      return { data: r.data ?? null, error: r.error?.message || null };
    }
    return { data: null, error: "Missing booking_id or booking_code" };
  } catch (e: any) {
    return { data: null, error: e?.message || "Booking lookup failed" };
  }
}

async function tryUpdateBooking(
  supabase: ReturnType<typeof createClient>,
  bookingId: string,
  patch: Record<string, any>
): Promise<{ ok: boolean; data: any | null; error: string | null }> {
  try {
    const r = await supabase
      .from("bookings")
      .update(patch)
      .eq("id", bookingId)
      .select("*")
      .maybeSingle();
    if (r.error) return { ok: false, data: null, error: r.error.message };
    return { ok: true, data: r.data ?? null, error: null };
  } catch (e: any) {
    return { ok: false, data: null, error: e?.message || "Booking update failed" };
  }
}

// Best-effort: keep driver status roughly aligned (non-blocking)
function driverStatusForBookingStatus(status: string): string | null {
  const s = norm(status);
  if (s === "assigned") return "assigned";
  if (s === "on_the_way" || s === "enroute") return "on_the_way";
  if (s === "arrived") return "arrived";
  if (s === "on_trip") return "on_trip";
  if (s === "completed") return "available";
  if (s === "cancelled") return "available";
  return null;
}

async function bestEffortUpdateDriverLocation(
  supabase: ReturnType<typeof createClient>,
  driverId: string,
  bookingStatus: string
): Promise<{ warning?: string }> {
  const mapped = driverStatusForBookingStatus(bookingStatus);
  if (!driverId || !mapped) return {};

  try {
    const r = await supabase
      .from("driver_locations")
      .update({ status: mapped, updated_at: new Date().toISOString() })
      .eq("driver_id", driverId);

    if (r.error) {
      return { warning: "DRIVER_LOCATION_STATUS_UPDATE_ERROR: " + r.error.message };
    }
    return {};
  } catch (e: any) {
    return { warning: "DRIVER_LOCATION_STATUS_UPDATE_ERROR: " + (e?.message || "Unknown error") };
  }
}

/**
 * PHASE 3L - wallet sync (completion only)
 * IMPORTANT: Do NOT call admin_finalize_trip_and_credit_wallets(text)
 * because you have a DB trigger that credits driver wallet on status -> completed.
 * Calling finalize could double-credit driver earnings.
 *
 * What we DO:
 * - apply platform cut via process_booking_wallet_cut(p_booking_id uuid)
 * - for takeout: sync vendor wallet via sync_vendor_takeout_wallet(v_vendor_id uuid)
 */
async function bestEffortWalletSyncOnComplete(
  supabase: ReturnType<typeof createClient>,
  booking: any
): Promise<{ warning?: string }> {
  const bookingId = booking?.id ? String(booking.id) : null;
  const serviceType = String(booking?.service_type ?? booking?.serviceType ?? "").toLowerCase();
  const vendorId = booking?.vendor_id ? String(booking.vendor_id) : null;

  const warnings: string[] = [];

  // 1) Apply platform/company cut (driver wallet deduction)
  if (bookingId) {
    try {
      const r: any = await supabase.rpc("process_booking_wallet_cut", {
        p_booking_id: bookingId,
      });
      if (r?.error) warnings.push("WALLET_CUT_RPC_ERROR: " + r.error.message);
    } catch (e: any) {
      warnings.push("WALLET_CUT_RPC_ERROR: " + String(e?.message || e));
    }
  } else {
    warnings.push("WALLET_CUT_SKIPPED_NO_BOOKING_ID");
  }

  // 2) Vendor wallet for takeout only
  if (serviceType === "takeout" && vendorId) {
    try {
      const r: any = await supabase.rpc("sync_vendor_takeout_wallet", {
        v_vendor_id: vendorId,
      });
      if (r?.error) warnings.push("VENDOR_SYNC_RPC_ERROR: " + r.error.message);
    } catch (e: any) {
      warnings.push("VENDOR_SYNC_RPC_ERROR: " + String(e?.message || e));
    }
  }

  return warnings.length ? { warning: warnings.join("; ") } : {};
}

export async function GET(req: Request) {
  const supabase = createClient();
  try {
    const url = new URL(req.url);
    const bookingId = url.searchParams.get("booking_id") || url.searchParams.get("id");
    const bookingCode = url.searchParams.get("booking_code") || url.searchParams.get("code");

    const bk = await fetchBooking(supabase, bookingId ?? null, bookingCode ?? null);
    if (!bk.data) {
      return jsonErr(
        "BOOKING_NOT_FOUND",
        bk.error || "Booking not found",
        404,
        { booking_id: bookingId ?? null, booking_code: bookingCode ?? null }
      );
    }

    const booking: any = bk.data;
    const cur = norm(booking.status) || "requested";
    const allowedNext = NEXT[cur] ?? [];
    const hasDriver = !!booking.driver_id;

    return jsonOk({
      ok: true,
      booking_id: String(booking.id),
      booking_code: booking.booking_code ?? null,
      current_status: cur,
      has_driver: hasDriver,
      allowed_next: allowedNext,
      booking,
    });
  } catch (e: any) {
    return jsonErr("SERVER_ERROR", e?.message || "Unknown error", 500);
  }
}

export async function POST(req: Request) {

  // ===== JRIDE_P5C_POST_START_BLOCK (fare history prep; best-effort) =====
  // Runs early inside POST() async scope. Does NOT depend on later local variables.
  // It attempts to derive booking id/code from body/payload/data and fetch booking for signature + suggestion.

  let fare_signature: string | null = null;
  let p5c_warning: string | null = null;

  // Helper: stable rounding
  const __p5c_round6 = (v: any) => {
    const n = Number(v);
    if (!Number.isFinite(n)) return null;
    return Math.round(n * 1e6) / 1e6;
  };

  const __p5c_sigFrom = (b: any): string | null => {
    const pLat = __p5c_round6(b?.pickup_lat);
    const pLng = __p5c_round6(b?.pickup_lng);
    const dLat = __p5c_round6(b?.dropoff_lat);
    const dLng = __p5c_round6(b?.dropoff_lng);
    if (pLat === null || pLng === null || dLat === null || dLng === null) return null;
    return `${pLat},${pLng}|${dLat},${dLng}`;
  };

  const __p5c_num = (v: any): number | null => {
    if (v === null || typeof v === "undefined") return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  // We will attempt after body parse exists; this block expects later code defines `body` OR uses req.json()
  // So we do nothing here yet; we run after body is available by wrapping in a microtask below.
  Promise.resolve().then(async () => {
    try {
      // Try to use any of these names if they exist in this scope
      const src: any =
        (typeof (globalThis as any).body !== "undefined" ? (globalThis as any).body : null) ??
        (typeof (globalThis as any).payload !== "undefined" ? (globalThis as any).payload : null) ??
        (typeof (globalThis as any).data !== "undefined" ? (globalThis as any).data : null) ??
        null;

      // Fallback: try to read request JSON again only if needed (safe best-effort)
      let bdy: any = null;
      try { bdy = await (req as any).json(); } catch { bdy = null; }

      const s = src ?? bdy ?? {};
      const id = String(s.booking_id ?? s.bookingId ?? s.id ?? "").trim();
      const code = String(s.booking_code ?? s.bookingCode ?? s.code ?? "").trim();

      if (!id && !code) return;
      if (typeof supabase === "undefined" || !supabase) return;

      // Fetch booking
      let q: any = supabase
        .from("bookings")
        .select("pickup_lat,pickup_lng,dropoff_lat,dropoff_lng,town,vehicle_type,verified_fare");

      if (id) q = q.eq("id", id);
      else q = q.eq("booking_code", code);

      const r: any = await q.order("updated_at", { ascending: false, nullsFirst: false }).limit(1).maybeSingle();
      if (r?.error) {
        p5c_warning = "P5C_BOOKING_FETCH_ERROR: " + String(r.error.message || "fetch failed");
        return;
      }

      const booking = r?.data || null;
      fare_signature = __p5c_sigFrom(booking);

      const vf = __p5c_num(booking?.verified_fare);
      if (!fare_signature || vf === null) return;

      const town = String((booking?.town ?? "") || "").trim() || null;
      const vehicle = String((booking?.vehicle_type ?? "") || "").trim() || null;

      try {
        const ru: any = await supabase.rpc("fare_suggestion_upsert_v1", {
          route_signature: fare_signature,
          town_name: town,
          vehicle_type_in: vehicle,
          verified_fare_in: vf,
        });
        if (ru?.error) {
          p5c_warning = "P5C_RPC_ERROR: " + String(ru.error.message || "rpc failed");
        }
      } catch (e: any) {
        p5c_warning = "P5C_RPC_EXCEPTION: " + String(e?.message || e);
      }
    } catch (e: any) {
      p5c_warning = "P5C_BLOCK_EXCEPTION: " + String(e?.message || e);
    }
  });
  // ===== END JRIDE_P5C_POST_START_BLOCK =====

  const supabase = createClient();
  const rawBody = (await req.json().catch(() => ({}))) as any;

  const booking_id =
    rawBody?.booking_id ??
    rawBody?.bookingId ??
    rawBody?.id ??
    rawBody?.booking?.id ??
    null;

  const booking_code =
    rawBody?.booking_code ??
    rawBody?.bookingCode ??
    rawBody?.code ??
    rawBody?.booking?.booking_code ??
    rawBody?.booking?.bookingCode ??
    null;

  const status = rawBody?.status ?? null;
  const note = rawBody?.note ?? null;
  const force = Boolean(rawBody?.force);

  if ((!booking_id || String(booking_id).trim() === "") && (!booking_code || String(booking_code).trim() === "")) {
    return jsonErr("BAD_REQUEST", "Missing booking identifier", 400);
  }
  if (!status) {
    return jsonErr("BAD_REQUEST", "Missing target status", 400);
  }

  const target = norm(status);
  if (!target || !(ALLOWED as any).includes(target)) {
    return jsonErr("INVALID_STATUS", "Invalid status. Allowed: " + ALLOWED.join(", "), 400);
  }

  const bk = await fetchBooking(
    supabase,
    booking_id ? String(booking_id).trim() : null,
    booking_code ? String(booking_code).trim() : null
  );

  if (!bk.data) {
    return jsonErr("BOOKING_NOT_FOUND", bk.error || "Booking not found", 404, {
      booking_id: booking_id ?? null,
      booking_code: booking_code ?? null,
    });
  }

  const booking: any = bk.data;
  const cur = norm(booking.status) || "requested";
  const allowedNext = NEXT[cur] ?? [];
  const hasDriver = !!booking.driver_id;

  // PHASE 3L: Trip lock
  if ((cur === "completed" || cur === "cancelled") && cur !== target) {
    return jsonErr("TRIP_LOCKED", "Trip already " + cur + " (no further updates allowed)", 409, {
      booking_id: String(booking.id),
      booking_code: booking.booking_code ?? null,
      current_status: cur,
      target_status: target,
    });
  }

  // Require driver for lifecycle statuses (except requested/cancelled)
  if (!hasDriver && target !== "requested" && target !== "cancelled") {
    return jsonErr("NO_DRIVER", "Cannot set status without driver_id", 409, {
      booking_id: String(booking.id),
      booking_code: booking.booking_code ?? null,
      current_status: cur,
      target_status: target,
      has_driver: hasDriver,
      allowed_next: allowedNext,
      current_status_raw: booking.status ?? null,
    });
  }

  // Idempotent retry
  if (cur === target) {
    return jsonOk({
      ok: true,
      changed: false,
      idempotent: true,
      booking_id: String(booking.id),
      booking_code: booking.booking_code ?? null,
      status: booking.status ?? null,
      booking,
    });
  }

  // Strict transitions unless forced
  if (!force && !allowedNext.includes(target)) {
    return jsonErr("INVALID_TRANSITION", "Cannot transition " + cur + " -> " + target, 409, {
      booking_id: String(booking.id),
      booking_code: booking.booking_code ?? null,
      current_status: cur,
      target_status: target,
      has_driver: hasDriver,
      allowed_next: allowedNext,
    });
  }

  // Best-effort timestamps + note (falls back to status-only if columns missing)
  const nowIso = new Date().toISOString();
  const patch: Record<string, any> = { status: target };

  if (target === "assigned") patch.assigned_at = nowIso;
  if (target === "on_the_way" || target === "enroute") patch.enroute_at = nowIso;
  if (target === "arrived") patch.arrived_at = nowIso;
  if (target === "on_trip") patch.on_trip_at = nowIso;
  if (target === "completed") patch.completed_at = nowIso;
  if (target === "cancelled") patch.cancelled_at = nowIso;

  if (note && String(note).trim() !== "") {
    patch.status_note = String(note).trim();
  }

  let upd = await tryUpdateBooking(supabase, String(booking.id), patch);

  if (!upd.ok && upd.error && upd.error.toLowerCase().includes("column")) {
    upd = await tryUpdateBooking(supabase, String(booking.id), { status: target });
  }

  if (!upd.ok) {
    return jsonErr("DISPATCH_STATUS_DB_ERROR", upd.error || "Booking update failed", 500, {
      booking_id: String(booking.id),
      booking_code: booking.booking_code ?? null,
      current_status: cur,
      target_status: target,
    });
  }

  const updatedBooking = upd.data ?? booking;

  // Driver location sync (non-blocking)
  const driverId =
    updatedBooking?.driver_id ? String(updatedBooking.driver_id) :
    (booking?.driver_id ? String(booking.driver_id) : "");

  const drv = await bestEffortUpdateDriverLocation(supabase, driverId, target);

  // Audit (non-blocking)
  const actor = getActorFromReq(req);
  const audit = await bestEffortAudit(supabase, {
    booking_id: String(booking.id),
    booking_code: booking.booking_code ?? null,
    from_status: cur,
    to_status: target,
    actor,
    source: "dispatch/status",
  });

  // Wallet sync (completion only)
  let walletWarn: string | null = null;
  if (target === "completed") {
    const w = await bestEffortWalletSyncOnComplete(supabase, updatedBooking);
    walletWarn = w.warning ?? null;
  }

  const warn =
    drv.warning
      ? (audit.warning ? (String(drv.warning) + "; " + String(audit.warning)) : String(drv.warning))
      : (audit.warning ? String(audit.warning) : null);

  const mergedWarn =
    warn
      ? (walletWarn ? (String(warn) + "; " + String(walletWarn)) : String(warn))
      : (walletWarn ? String(walletWarn) : null);

  return jsonOk({
    ok: true,
    changed: true,
    booking_id: String(booking.id),
    booking_code: booking.booking_code ?? null,
    status: target,
    allowed_next: NEXT[target] ?? [],
    booking: updatedBooking ?? null,
    warning: mergedWarn,
  });
}

============================================================
app\passenger\page.tsx
------------------------------------------------------------
"use client";

export const dynamic = "force-dynamic";

import * as React from "react";
import { useRouter } from "next/navigation";

export default function PassengerDashboardPage() {
  const router = useRouter();

  const [loading, setLoading] = React.useState(true);
  const [authed, setAuthed] = React.useState(false);
  const [verified, setVerified] = React.useState(false);
  const [nightAllowed, setNightAllowed] = React.useState(false);

  React.useEffect(() => {
    let alive = true;
    (async () => {
      try {
        const r = await fetch("/api/public/auth/session", { cache: "no-store" });
        const j: any = await r.json().catch(() => ({}));
        if (!alive) return;
        const ok = !!j?.authed;
        setAuthed(ok);
        setVerified(!!j?.user?.verified);
        setNightAllowed(!!j?.user?.night_allowed);
      } catch {
        if (!alive) return;
        setAuthed(false);
      } finally {
        if (!alive) return;
        setLoading(false);
      }
    })();
    return () => { alive = false; };
  }, []);

  function gotoLogin() {
    router.push("/passenger-login");
  }

  function goBookRide() {
    if (!authed) return gotoLogin();
    router.push("/ride");
  }

  return (
    <main className="min-h-screen flex items-center justify-center p-6 bg-white">
      <div className="w-full max-w-2xl rounded-2xl border border-black/10 bg-white p-6 shadow-sm">
        <div className="flex items-start justify-between gap-3">
          <div>
            <h1 className="text-2xl font-semibold mb-1">Passenger Dashboard</h1>
            <p className="text-sm opacity-70 mb-5">Choose what you want to do.</p>
          </div>
          <div className="text-xs rounded-full border border-black/10 px-3 py-1">
            <span className="font-semibold">{authed ? "Signed in" : "Guest"}</span>
            <span className="opacity-70">{" - "}{loading ? "loading" : authed ? "session ok" : "no session"}</span>
          </div>
        </div>

        {!authed ? (
          <div className="rounded-xl border border-amber-200 bg-amber-50 px-3 py-2 text-amber-900">
            <div className="font-semibold">Sign in required</div>
            <div className="opacity-80">To book a ride, please sign in first.</div>
          </div>
        ) : null}

        {authed && !verified ? (
          <div className="mt-3 rounded-xl border border-slate-200 bg-slate-50 px-3 py-2 text-slate-800">
            <div className="font-semibold">Verification may be required (8PM-5AM)</div>
            <div className="opacity-80 text-xs mt-1">
              Verified: {String(verified)} | Night allowed: {String(nightAllowed)}
            </div>
            <div className="opacity-80 text-xs mt-1">
              Next: add Complete Profile / Submit for approval.
            </div>
          </div>
        ) : null}

        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mt-5">
          <button
            type="button"
            onClick={goBookRide}
            className="text-left rounded-xl border border-blue-500 bg-blue-500/10 px-4 py-3"
          >
            <div className="font-semibold">Book Ride</div>
            <div className="text-sm opacity-70">Go to ride booking</div>
          </button>

          <button
            type="button"
            onClick={() => (authed ? router.push("/takeout") : gotoLogin())}
            className="text-left rounded-xl border border-black/10 bg-white hover:bg-black/5 px-4 py-3"
          >
            <div className="font-semibold">Takeout</div>
            <div className="text-sm opacity-70">Food delivery (pilot)</div>
          </button>

          <button
            type="button"
            onClick={() => (authed ? router.push("/errand") : gotoLogin())}
            className="text-left rounded-xl border border-black/10 bg-white hover:bg-black/5 px-4 py-3"
          >
            <div className="font-semibold">Errands</div>
            <div className="text-sm opacity-70">Pabili / padala (pilot)</div>
          </button>
        </div>

        <div className="mt-5 flex gap-3">
          <button
            type="button"
            onClick={() => (authed ? router.push("/ride") : gotoLogin())}
            disabled={loading}
            className={
              "rounded-xl px-5 py-2 font-semibold text-white " +
              (loading ? "bg-blue-600/60 cursor-not-allowed" : "bg-blue-600 hover:bg-blue-500")
            }
          >
            {loading ? "Loading..." : authed ? "Continue" : "Sign in to continue"}
          </button>

          <button
            type="button"
            onClick={gotoLogin}
            className="rounded-xl border border-black/10 hover:bg-black/5 px-5 py-2 font-semibold"
          >
            Switch Account
          </button>
        </div>

        <div className="mt-4 text-xs opacity-70">
          Note: Next step is to connect verification + night rules (8PM-5AM).
        </div>
      </div>
    </main>
  );
}